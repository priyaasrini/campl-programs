\documentclass[11pt]{article}
\input{preamble}
\input{macros}
\addbibresource{refs.bib}
\linespread{1.11}

\title{Categorical Message Passing Language (CaMPL)}
\author{
    Robin Cockett\thanks{University of Calgary} \and Daniel Hashimoto\thanks{Universidade Federal do Rio de Janeiro} \and Alexanna Little* \and Melika Norouzbeygi* \and Priyaa Varshinee Srinivasan\thanks{Tallinn University of Technology}}
%\def\authorrunning{D.\ I.\ Spivak \& P.\ V.\ Srinivasan}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
This document is a simple introduction to  a novel concurrent programming language called the 
categorical message passing language built on the mathematics of linear actegories. 
Categorical Message Passing Language, to the best of our knowledge, 
the only\footnote{Is this true?} concurrent programming language with mathematical underpinnings. 
It is a functional-style programming language with the abstract machine built on Haskell. 
The current version of CaMPL compiler is to be considered a proto-alpha, a proof-of-concept 
of a programming language built from the mathematics of linear actegories.
\end{abstract}

%\addcontentsline{toc}{section}{References}

\tableofcontents

\section{Introduction}

Explain current state of concurrency and why CaMPL is novel (Curry-Howard-Lambek-like correspondence), and its history.

\section{A brief overview of CaMPL}


\section{Concurrent types}


At any instance in run-time, the topology of a CaMPL program is a finite acyclic graph consisting of {\em processes} which are nodes of the graph and {\em channels} which are the edges of the graph. The following table draws analogue between the constructs of sequential and concurrent MPL.

\begin{center}
\begin{tabular}{ | c ||  c | c | c | }
 \hline
 {\bf Sequential} & Functions & Data type   & Instance \\ 
   & & (and coData type)   &  \\
 \hline
 {\bf Concurrent} & Processes & Protocol  & Channel \\  
 & & (and coProtocol)    &  \\
 \hline
\end{tabular}
\end{center} 


\subsection{Processes}

Processes are the main actors of a CaMPL program. In CaMPL, a {\em process} is specified by a process name and an optional type signature. The type signature of a process consists of: 
\begin{itemize}
	\item an optional comma-seperated list of sequential types, say {\em A1, ..., Ak},
    \item an optional comma-seperated list of input concurrent types, say {\em I1, ..., In}, and
	\item an optional comma-seperated list of output concurrent types, say {\em O1, ..., Om}.
\end{itemize}
The instances of concurrent types are called {\em channels}.

A CaMPL process is given by the following syntax (the CaMPL tokens are specified by {\tt typewriter} font and in red color) :-

  \begin{center}
    \textcolor{red}{\tt proc} {\em procName} \textcolor{red}{\tt ::} $~A_1, \ldots, A_k~$ \textcolor{red}{ \tt | } $~I_1, \ldots, I_n~$ \textcolor{red}{  \tt => } $~O_1, \ldots, O_m~$ \textcolor{red}{ \tt = }
    
    \quad \quad \quad \quad \quad \quad   $~a_{11}, \ldots, a_{1k}~$ \textcolor{red}{ \tt | } $~i_{1},\ldots,i_{n}~$ \textcolor{red}{  \tt => } $~{o_{1}, \ldots, o_{m}}~$ \textcolor{red}{ \tt -> } {\em procBody$_1$} \\
    ... \\ 
    ... \\ 
    \quad \quad \quad \quad \quad \quad   $~a_{p1}, ..., a_{pk}~$ \textcolor{red}{ \tt | } $~i_{1},\ldots,i_{n}~$ \textcolor{red}{  \tt => } $~{o_{1}, \ldots, o_{m}}~$ \textcolor{red}{ \tt -> } {\em procBody$_p$}
  \end{center}
The type signature is optional and may be omitted. The process definition may pattern-match on sequential types. We call the list of channels $i_1, \ldots, i_n$ occurring to the left of {\tt =>} as {\em input polarity} or {\em left polarity} channels. We call the list of channels $o_1, \ldots, o_m$ occurring to the right of {\tt =>} as {\em output polarity} or {\em right polarity} channels. We also say that the channels $i_1, \ldots, i_n$ and $o_1, \ldots, o_m$ are in the scope of the process body --- operationally, this means that these channels can be accessed inside the {\em procBody$_p$}. 

The polarity of the channels encode the bidirectional flow of information. When a process sends message over an output/right polarity channel (to another process), then the information flows  towards right. If a process receives message over an output/right polarity channel (from another process), then the information flows towards the left. We explain sending and receiving messages over input and output polarity channels in more detail in Section \ref{subsec:put-get}.

  \[ \xymatrix{ \ar@{-}[r]^{I_1,~\ldots,~ I_n \quad \quad}  & ~~ \blackman  ~~ \ar@{-}[r]^{\quad \quad O_1,~\ldots,~ O_m} &    } \]
  
The process body {\em procBody} may be a single process command written as as {\em procCmd} or a {\tt do} block of process commands taking one of the following forms:-
\begin{center}
\begin{minipage}[t]{0.2\textwidth}
{\tt do } 

\quad \quad {\em procCmd}$_1$ 
 
\quad \quad {\em procCmd}$_2$ 

\quad \quad $\cdots$ 

\quad \quad {\em procCmd}$_n$  
\end{minipage}
\begin{minipage}[t]{0.3\textwidth}
{\tt do } 

\quad \quad {\em procCmd}

\quad \quad $\cdots$ 

\quad \quad {\tt if } {\em expr}

\quad \quad \quad \quad {\tt then } {\em procBody}$_1$  

\quad \quad \quad \quad {\tt else } {\em procBody}$_2$  
\end{minipage}
\begin{minipage}[t]{0.45\textwidth}
{\tt do } 

\quad \quad {\em procCmd}

\quad \quad $\cdots$ 

\quad \quad {\tt case } {\em expr} {\tt of}

\quad \quad \quad \quad $C_1(a_{11, \ldots,a_{1n}})$ {\tt ->} {\em procBody}$_1$

\quad \quad \quad \quad $\cdots$ 

\quad \quad \quad \quad $C_1(a_{p1, \ldots,a_{pn}})$ {\tt ->} {\em procBody}$_p$  
\end{minipage}
\end{center}

Note that a {\tt do} block ends with a {\em procCmd} or an {\tt if} statement or a {\tt case} statement. A {\em procBody}$_i$ may be an invokation of another process. The process commands facilitated by CaMPL are elaborated in Section \ref{Sec:concurrent-commands}.

\subsection{Channels}

In CaMPL, processes talk to each other, that is, send and receive messages, via channels. CaMPL comes with built-in channel types from which one may build custom channel types. For any process {\tt p}, the behavior of the channels depends on the polarity.The polarity of a channel determines the kind of operations that my be performed on the channel, see Section \ref{sec:concurrent-operators}.

\subsubsection{Built-in Channel types}

The following information is from \cite[Section 3.3.2]{Prashanth-thesis}.

\begin{tabular}{r l}
{\tt Get (A|Ch)} & channel type  takes a sequential type {\tt A} and a channel of type {\tt Ch}. \\
{\tt Put (A|Ch)} & channel type takes a sequential type {\tt A} and a channel of type {\tt Ch}. \\ 
{\tt Neg (Ch)} & channel type takes a channel of type {\tt P}. \\ 
{\tt TopBot} & which is acronym for {\tt Top} and {\tt Bottom} does not take arguments. \\
{\tt Ch1 (+) Ch2} & takes in two channels of types {\tt Ch1} and {\tt Ch2} \\
{\tt Ch1 (*) Ch2} & takes in two channels of types {\tt Ch1} and {\tt Ch2}

\end{tabular}



\subsubsection{Constructing custom channel types}

In CaMPL, a programmer may built channels of custom types from the built-in types using {\tt protocol} keyword. Protocols are concurrent analogue of dataypes from the sequential world, and channels are concurrent analogue of instances of datatypes.

Let us consider the following example of a protocol (from Example ??):

\begin{center}
\begin{varwidth}{\linewidth}
\begin{verbatim}
protocol Echo => S =
    EchoSend :: Put( [Char] | Get( [Char] | S)) => S
    EchoClose :: TopBot => S
\end{verbatim}
\end{varwidth}
\end{center}

In the above code, {\tt Echo} is a type constructor that takes in an right conncurrent type {\tt S}. {\tt EchoSend} and {\tt EchoClose} are called {\bf protocol handles}. A channel of type Echo is {\em activated} when a process puts a handle on the on it using {\sf hput} (See Section \ref{subsec:pairs}). Once a channel activated, the channel may be used for communication by the processes it is connected to according to the rules of the handle. For example, {\tt EchoSend} enables sending and receiving over {\tt S} using {\tt Put} and {\tt Get} (see Section \ref{subsec:put-get}), and {\tt EchoClose} takes in {\tt S} and converts it into {\tt TopBot} type (thereby disallowing any further communication).

Let us consider the following example of a protocols (from Example ??):

\begin{center}
\begin{varwidth}{\linewidth}
\begin{verbatim}
protocol Passer( | M ) => S =
    Passer :: M (+) (Neg(M) (*) S)  => S
\end{verbatim}
\end{varwidth}
\end{center}

In the above code, {\tt Passer} is a type constructor takes in a left concurrent type {\tt M} and a right concurrent type {\tt S}. The handle {\tt Passer} takes in a {\tt S} type and produces a compound type {\tt M (+) (Neg(M) (*) S)}.

\begin{center}
\begin{varwidth}{\linewidth}
\begin{verbatim}
protocol MemCell (A | ) => S =
    MemPut :: Put(A|S) => S
    MemGet :: Get(A|S) => S
    MemCls :: TopBot => S
\end{verbatim}
\end{varwidth}
\end{center}

In the above code, {\tt MemCell} is a type constructor takes in an input sequential type {\tt A} and a right concurrent type {\tt S}. The handle {\tt MemPut} and {\tt MemGet} takes in a {\tt S} type and enables send-receive of type {\tt A} over {\tt S}. The handle {\tt MemCls} takes in a {\tt S} type and produces a {\tt TopBot} which ends all communication.

Dual to protocols, CaMPL supports {\tt coprotocol}s signifying the inherent duality in direction of information flow between two processes --- from left to right, or from right to left. For example, consider the following protocol and coprotocols.

\begin{center}
\begin{varwidth}{\linewidth}
\begin{verbatim}
protocol EchoSimple => S =
    EchoSend :: Put( [Char] | S)) => S
    
coprotocol coEchoSimple => S =
    coEchoSend ::  S  => Put( [Char] | S))
\end{verbatim}
\end{varwidth}
\end{center}

Suppose {\tt ch} is a channel with the handle {\tt EchoSend}, the message is sent from right polarity to left polarity, as shown in (1) and (2) in the following figure. One can use a coprotocol to avoid bending wires as shown in (3).
\[ \includegraphics[scale=0.12]{figs/coprotocol.jpeg} \]
A coprotocol is an added functionality rather than being a unique feature. All our examples use {\tt protocol} keyword to construct custom types.


\section{Concurrent operators}
\label{sec:concurrent-operators}
\label{Sec:concurrent-commands}

Table \ref{tab:mpl-constructs} summarizes the operations on the concurrent types.

 \begin{table}[!h]
\centering
	\begin{tabular}{|l|l|l|}
	\hline
	{\tt id} & equates two channels &  non-blocking  \\ \hline
	{\tt neg} & negates a channel & non-blocking \\ \hline
	{\tt plug} & connects two processes by a channel & non-blocking \\ \hline
	{\tt get} & send/receive a value on a channel & blocking \\ \hline
	{\tt put} & send/receive a value on a channel &  non-blocking \\ \hline
	{\tt hput} & puts a handle on a channel & non-blocking \\ \hline
	{\tt hcase} & cases on the handles obtained on channel & blocking \\ \hline
	{\tt split} & splits a channel into two channels  & blocking\\ \hline
	{\tt fork} & forks two new processes & non-blocking \\ \hline
	{\tt close} & closes a channel & non-blocking \\ \hline
	{\tt halt} & closes a channel. Usually the last channel is halted. & non-blocking \\ \hline
	\end{tabular}
\caption{Concurrent MPL Constructs}
\label{tab:mpl-constructs}
\end{table} 

\subsection{Connecting processes using {\tt plug}}

\begin{center}
\begin{varwidth}{\linewidth}
\begin{verbatim}
	plug 
		    process1( .. | ch1 => ch2)
		    process2( .. | ch2 => ch3)
		    process3( .. | ch3 => ch4)
		    ...
		    processn( .. | chn => last_ch)
\end{verbatim}
\end{varwidth}
\end{center}

Composition of two or more processes in the concurrent side of CaMPL is defined by 
{\em plug} command. Two processes can only be plugged to each other along a channel, if 
\begin{itemize}
	\item they share a channel of the same type but opposite polarity and 
	\item they do not have an existing connection.
\end{itemize}

The processes which are plugged together run in parallel, and may communicate via the channels connecting them. The following code demonstrates a usage of the {\tt plug} command. 

\begin{center}
\begin{varwidth}{\linewidth}
\begin{verbatim}
	1. proc pulgDemo :: A | X => Z = 
	2.	    a | x => z -> 
	3.		    plug 
	4.			       processA(a | x => y)
	5.			       processB(a | y => z)
\end{verbatim}
\end{varwidth}
\end{center}

A detailed explanation of the code is as follows:

\begin{itemize}
\item Line {\tt 1.} provides the type signature of the process {\tt plugDemo}. The process has a sequential argument of type {\tt A}, an input polarity channel of type {\tt X}, and an output polarity channel of type {\tt Z}.

\item Line {\tt 2.} provides variable names to the sequential and concurrent types.

\item Lines {\tt 3-5.} cause {\tt processA} and {\tt process B} to be connected by  channel {\tt y} and to be run in parallel. The channel {\tt y} is of output polarity for {\tt processA} and input polarity for {\tt processB}. Note that, the sequential argument of type {\tt A} is duplicated, and passed to both {\tt ProcessA} in line {\tt 3} and {\tt ProcessB} in line {\tt 4}. Such duplication is not allowed for channels (since channels are linear resources).
\end{itemize}

A process is not allowed to create new channel except in the {\tt plug} command, for example channel {\tt y}. The {\tt plug} command can only occur as the last command in a process block. 

\textcolor{red}{Question to Robin: Are the processes which are plugged created new?}

\subsection{Equating channels using {\tt id} and {\tt neg}}
\label{sec:neg}

The {\tt id} command is used equate to two channels of opposite polarities while {\tt neg} command is used to equate two channel of same polarities. The following code snippet demonstrates the usage of these commands:
\begin{center}
	\begin{varwidth}{\linewidth}
		\begin{verbatim}
			1. proc equateChannels :: | A, Neg(A) => A = 
			2.		  | a, neg_a => a' -> 
			3.		       a |=| a'						                    -- equating
			4.		       neg_a |=| neg(a)                  -- equating after negating
		\end{verbatim}
	\end{varwidth}
\end{center} 

A detailed explanation of the code is as follows:

\begin{itemize}
\item Line {\tt 1.} provides the type signature of the process {\tt equateChannels}. The process has no sequential arguments, two input polarity channel of type {\tt A} and {\tt Neg(A)}, and an output polarity channel of type {\tt A}.

\item Line {\tt 2.} provides variable names to the concurrent types.

\item Line {\tt 3.} equates the input channel {\tt a} to output channel {\tt a'}, both of type {\tt A}.

\item Line {\tt 4.} first negates channel  {\tt a} --- since {\tt a} is an input channel of type {\tt A}, {\tt neg(a)} is an output channel of type {\tt Neg(A)}. Then, it equates input channel {\tt neg\_a} of type {\tt Neg(A)} with {\tt neg(a)}.

\end{itemize}

\subsection{Ending communication using {\tt halt} and {\tt close}}

\begin{center}
	\begin{varwidth}{\linewidth}
		\begin{verbatim}
			 close <channel_1>
			 close <channel_2>
			 ...
			 halt <channel_n>		 
		\end{verbatim}
	\end{varwidth}
\end{center} 

\vspace{-1em}

A process may use {\tt close} and the {\tt halt} commands to close its channels, that is, terminate any interaction along those channels, and remove those channels out of scope. The {\tt halt} command halts a process after closing the last channel (to be closed). The {\tt halt} command is expected to be the last command of a process block. Closing a channel of any (co)protocol type results in built-in channel type {\tt TopBot}.

The following is a simple process demonstrating the usage of {\tt close} and {\tt halt}.
\begin{center}
	\begin{varwidth}{\linewidth}
		\begin{verbatim}
			1. proc noInteraction :: | TopBot => TopBot = 
			2. 	| chA => chB -> do
			3.		close chA
			4.		halt chB	 
		\end{verbatim}
	\end{varwidth}
\end{center} 
A detailed explanation of the code is as follows:

\begin{itemize}
\item Line {\tt 1.} provides the type signature of the process {\tt noInteraction}. The process has no sequential arguments, an input polarity channel of type {\tt TopBot}, and an output polarity channel of type {\tt TopBot}.

\item Line {\tt 2.} provides variable names to the concurrent types. Since {\tt chA} and {\tt chB} are channels of type {\tt TopBot}, all interactions on these channels can be stopped.

\item Line {\tt 3.} closes {\tt chA} which mean it will be out of scope in the rest of the process code.

\item Line {\tt 4.} closes {\tt chB} and terminates the process.

\end{itemize}
 
\subsection{Complementary operators }
\label{subsec:pairs}

A complementary pair in CAMPL is a pair of commands and is used for communication between two processes. For a complementary pair, one of the commands causes the calling process to wait until the other command is invoked (by the communicating process). For example, a  {\tt get}  command causes the calling process to wait to receive a value until the communicating process performs a {\tt put} command.

\subsubsection{Sending and receiving messages using {\tt put} and {\tt get}}
\label{subsec:put-get}

The semantics of message passing in CaMPL is given by a linear actegory. The operator $\circ$ 
in linear actegory corresponds to the {\tt Put(A|Ch)} and the operator $\bullet$ corresponds to 
the {\sf Get(A|Ch)} channel types. A process may perform {\tt put} and {\tt get} commands on 
channels of type either {\tt Put(A|Ch)} or {\tt Get(A|Ch)}.

\begin{figure}
\[  
 [{\tt Put}]: \quad \xymatrix{   
 \blackman  \quad
 \ar[rr]^{(r) \quad A \circ X \quad (l)}  
 &  & \quad \blackman   } \quad \quad \quad 
 [{\tt Get}]: \quad\xymatrix{  
 \blackman  \quad
 \ar@{<-}[rr]^{(r) \quad B \bullet X \quad (l)} 
 &  & \quad \blackman   }  
 \]
 \caption{Schematic of {\tt Put} and {\tt Get} types}
 \label{Fig: Put and Get}
\end{figure}

Given a channel of type \texttt{Put(A|X)}, a process may:
\begin{itemize}
	\item {\tt put} (send) a message of type {\tt A} over an output channel (left process sends), and
	\item {\tt get} (receive) a message of {\tt A} over an input channel (right process receives).
\end{itemize}

Dually, given a channel of type \texttt{Get(A|X)}, a process may:
\begin{itemize}
	\item {\tt get} (receive) a message of type {\tt A} over an output channel (left process receives), and
	\item {\tt put} (send) a message of {\tt A} over an input channel (right process sends) .
\end{itemize}

This means that over a channel of type {\tt Put(A|Ch)}, data of type {\tt A} flows towards the right.  This means that over a channel of type {\tt Get(A|Ch)}, data of type {\tt A} flows towards the left.  

\begin{figure}[h]
\begin{center}
	\begin{varwidth}{\linewidth}
		\begin{verbatim}
			Put( <sequential_type> | <concurrent_type> )
		\end{verbatim}
	\end{varwidth}

	\begin{varwidth}{\linewidth}
		\begin{verbatim}
			Get( <sequential_type> | <concurrent_type> )
		\end{verbatim}
	\end{varwidth}
\end{center}
\vspace{-2em}
\caption{Syntax for {\tt Put} and {\tt Get}}
\label{Fig: Put and Get syntax}
\end{figure}

% Side-by-side figures
\begin{figure}[h]
\begin{minipage}{.5\textwidth}
	\[ \infer[\circ_R]{B ~|~ X \dashvv A' \circ Y}{A \dashv A' \quad A, B ~|~ X \dashvv Y} \]
	\[ \infer[\circ_L]{A ~|~ B \circ X \dashvv Y}{A,B ~|~ X \dashvv Y} \]
  	\vspace{-2em}
  \captionof{figure}{Sequent rules for Put}
  \label{Fig: sequent rules for Put}
\end{minipage}%
\begin{minipage}{.5\textwidth}
	\[ \infer[\bullet_R]{B ~|~ X \dashvv A \circ Y}{A,B ~|~ X \dashvv Y} \]
	\[ \infer[\bullet_L]{A ~|~ B' \bullet X \dashvv Y}{B \dashv B' \quad \quad A,B ~|~ X \dashvv Y} \]
	\vspace{-2em}
  \captionof{figure}{Sequent rules for Get}
  \label{Fig: sequent rules for Get}
\end{minipage}
\end{figure}

Figure \ref{Fig: Put process} shows a sample communication over a channel of \texttt{Put(A|Ch)} 
type. Process \texttt{p} sends the string ``Sending on output channel" which is received by 
process \texttt{q}. 
Dually, in Figure \ref{Fig: Get process}, Process \texttt{q} sends a string ``Sending on input 
channel" which is received by \texttt{q}. 

% Side-by-side figures
\begin{figure}[h]
\centering
\begin{minipage}{.5\textwidth}
	\begin{verbatim}
		proc p :: A | => Put( [Char] | Y ) = 
			a | => y -> do
				send "Sending on output channel" on y
				halt y
			
		proc q ::  | Put( [Char] | Y ) =>  = 
			| y => do
				recv b on y
				halt y

	\end{verbatim}
  	\vspace{-3em}
  \captionof{figure}{Send-Receive via \texttt{Put}}
  \label{Fig: Put process}
\end{minipage}%
\begin{minipage}{.5\textwidth}
  \centering
	\begin{verbatim}
		proc q :: A | Get( [Char] | Y ) => = 
			a | y => -> do
				send "Sending on input channel" on y
				halt y
			
		proc p ::  | => Get( [Char] | Y )  = 
			| => y do
				recv b on y
				halt y

	\end{verbatim}
	\vspace{-3em}
  \captionof{figure}{Send-Receive via \texttt{Get}}
  \label{Fig: Get process}
\end{minipage}
\end{figure}

In Example {\bf EchoServer} in Section ??, in line ??, the handle {\tt EchoSend} constructs a channel of {\tt Put-Get} type allowing the {\tt server} to receive and send in sequence (or vice versa for the {\tt Client}).

The above described usage of \texttt{Put} and \texttt{Get} channel types apply for channels which are instances of Protocols. For coProtocols, the role of {\tt Put} and {\tt Get} gets reversed, as shown in the following tables:
\begin{center}
	\begin{tabular}{ c || c | c }
		     (P)       & (o) & (i) \\
		 \hline
		 \hline      
		 {\tt Get}  & {\tt recv}  & {\tt send} \\
		 \hline
		 {\tt Put}  & {\tt send}  & {\tt recv} 
	\end{tabular}
	\quad \quad 
	\begin{tabular}{ c || c | c }
		     (coP)       & (o) & (i) \\
		 \hline
		 \hline      
		 {\tt Get}  & {\tt send}  & {\tt recv} \\
		 \hline
		 {\tt Put}  & {\tt recv}  & {\tt send} 
	\end{tabular}
\end{center}

Read this as, if I (process) have an output channel which is a {\tt Put} type on a protocol, then I can {\tt send} (put) data on this channel. Alternatively, if I (process) have an input channel which is a {\tt Put} type on a protocol, then someone will be {\tt send}ing (putting) data on this channel for me.

If I (process) have an input channel which is a {\tt Get} type on a protocol, then I can {\tt recv} (get) data on this channel. Alternatively, if I (process) have an output channel which is a {\tt Get} type on a protocol, then someone will be {\tt recv}ing (getting) data on this channel from me.

\subsubsection{Activating channels using {\tt hcase} and {\tt hput}}

The {\tt hput} command sends a handle of a protocol over a right polarity channel which is matched by a {\tt hcase} command on the left polarity. For co-protocols, handles are sent over a left polarity channel and received over the corresponding right polarity channel. Figure \ref{Fig: hput and hcase} shows the syntax for {\tt hput} and {\tt hcase}.

\begin{figure}[h]
\begin{center}
	\begin{varwidth}{\linewidth}
		\begin{verbatim}
			hput <handle_name> on <channel_name>	
		\end{verbatim}
	\end{varwidth}

	\begin{varwidth}{\linewidth}
		\begin{verbatim}
			hcase <channel_name> of
				<handle1> -> ... 
				<handle2> -> ... 
				.
				.
				<handlen> -> ... 
		\end{verbatim}
	\end{varwidth}
\end{center}
\vspace{-2em}
\caption{Syntax for {\tt hput} and {\tt hcase}}
\label{Fig: hput and hcase}
\end{figure}

For example, in line ?? of the program shown in Section \ref{}, the {\tt Client}  hputs {\tt EchoClose} on channel {\tt ch} of type {\tt Echo}. This {\tt hput} is matched by {\tt hcase} in line ?? of the {\tt Server}. 


\subsubsection{Multichannel communication using {\tt split} and {\tt fork}}

\begin{figure}[h]
\begin{center}
	\begin{varwidth}{\linewidth}
		\begin{verbatim}
			fork <bundled_channel> as 
				<new_ch1> [with <channels>] -> <process1>
				<new_ch2> [with <channels>] -> <process2>
		\end{verbatim}
	\end{varwidth}

	\begin{varwidth}{\linewidth}
		\begin{verbatim}
			split <bundled_ch> into <new_ch1>, <new_ch2>
		\end{verbatim}
	\end{varwidth}
\end{center}
\vspace{-2em}
\caption{Syntax for fork and split}
\label{Fig: fork and split}
\end{figure}

The underlying mathematics of CaMPL allows plugging two processes along utmost one channel to avoid cycles. However, if one wishes to plug processes along more than one channel, one may do so safely (with no deadlocking) using {\sf split} and {\sf fork}. The tensor $(*)$ and the par $(+)$ functors (operators) bundles two or more channels together, and produces a new channel for communication (in linear actegories, $(*)$ and $(+)$ are written as $\otimes$ and $\oplus$ respectively).

If a process has a right polarity channel of type $A (*) B$, then it can {\sf fork} into two processes with two distinct channels $A$ and $B$ of right polarity. Dually, if a process is has a left polarity channel of type $A (+) B$, then it can {\sf fork} into two processes with two distinct channels $A$ and $B$ of left polarity. {\sf fork} is a non-blocking call. Accordingly, sequent rules for for fork are shown in Figure \ref{Fig: sequent rules fork}:
\begin{figure}[h]
	\[ \infer[\otimes_R]{A, B ~|~ X1, X2 \dashvv Y1 \otimes Y2}{A ~|~ X1 \dashvv Y1 \quad \quad B ~|~ X2 \dashvv Y2}  \quad \quad \quad \quad \quad \quad \infer[\oplus_L]{A,B ~|~ X1 \oplus X2 \dashvv Y1, Y2}{A ~|~ X1 \dashvv Y1 \quad \quad B ~|~ X2 \dashvv Y2} \]
\vspace{-2em}
\caption{Sequent rules for {\tt fork}}
\label{Fig: sequent rules fork}
\end{figure}

Figures \ref{Fig: fork1} show a process {\sf p} with a right polarity channel of type $Y1 (*) Y2$. Using the compound channel, the process forks into a process {\sf p} and a process {\sf q}. Similarly, Figure \ref{Fig: fork2} is an example of process forking.

% Side-by-side figures
\begin{figure}[h]
\centering
\begin{minipage}{.5\textwidth}
	\begin{verbatim}
		proc p :: A, B | X1, X2 => Y1 (*) Y2 = 
			a, b | x1, x2 => y -> 
				fork y as 
					y1 -> p(a | x1 => y1)
					y2 -> q(b | x2 => y2)
	\end{verbatim}
  	\vspace{-2em}
  \captionof{figure}{Process forking using {\tt (*)}}
  \label{Fig: fork1}
\end{minipage}%
\begin{minipage}{.5\textwidth}
  \centering
	\begin{verbatim}
		proc p :: A, B | X1 (+) X2 => Y1 ,Y2 = 
			a, b | x => y1, y2 -> 
				fork x as 
					x1 -> p(a | x1 => y1)
					x2 -> q(b | x2 => y2)
	\end{verbatim}  
	\vspace{-2em}
  \captionof{figure}{Process forking using {\tt (+)}}
  \label{Fig: fork2}
\end{minipage}
\end{figure}

If a process is connected to a left polarity channel of type {\tt A (*) B}, then it can {\sf split} the bundle into two distinct channels {\tt A} and {\tt B} of left polarity to be used by the process for further computations. Dually, if a process is connected to a right polarity channel of type {\tt A (+) B}, then it can {\sf split} the bundle into two two distinct channels {\tt A} and {\tt B} of right polarity. {\sf split} is a blocking call --- that is a process calling split will be blocked unless a {\sf fork} occurs at the other end of the same channel.

The sequent rules for {\sf split call} are shown in Figure \ref{Fig: sequent rules for split}.

\begin{figure}[h]
	\[ \infer[\otimes_R]{A ~|~ X1 \dashvv Y1 \oplus Y2}{A ~|~ X1 \dashvv Y1, Y2} \quad \quad \quad \quad \quad \quad \infer[\oplus_L]{A ~|~ X1, X2 \dashvv Y1}{A ~|~ X1 \otimes X2 \dashvv Y1} \]
\vspace{-2em}
\caption{Sequent rules for {\tt split}}
\label{Fig: sequent rules for split}
\end{figure}

Figure \ref{Fig: split1} shows a process {\sf q} splitting an left polarity and calling a process $p$. Dually, Figure \ref{Fig: split2} shows a process splitting on the right polarity.

% Side-by-side figures
\begin{figure}[h]
\centering
\begin{minipage}{.5\textwidth}
	\begin{verbatim}
		proc p :: A | X => Y1, Y2 = 
			a | x => y1, y2 -> ... 
			
		proc q :: A | X => Y1 (+) Y2 = 
			a, b | x => y -> do
					split y into y1, y2
					p( a | x => y1,y2)
	\end{verbatim}
  	\vspace{-2em}
  \captionof{figure}{Process splitting at the right polarity}
  \label{Fig: split1}
\end{minipage}%
\begin{minipage}{.5\textwidth}
  \centering
	\begin{verbatim}
		proc p :: A | X => Y1, Y2 = 
			a | x => y1, y2 -> ... 
		
		proc q :: A | X1 (*) X2 => Y = 
			a, b | x => y -> do
					split x into x1, x2
					p( a | x1,x2 => y)
	\end{verbatim}
	\vspace{-2em}
  \captionof{figure}{Process splitting at the left polarity}
  \label{Fig: split2}
\end{minipage}
\end{figure}

In Example ??, ... 

\subsection{Non-deterministic communication using {\tt race}}

\begin{center}
	\begin{varwidth}{\linewidth}
		\begin{verbatim}
			race 
				<ch_1> -> ...
				<ch_2> -> ...
				..
				<ch_n> -> ...
		\end{verbatim}
	\end{varwidth}
\end{center}

The {\tt race} command initiates a race condition between two or more channels of 
{\tt  Put(-|-)} or {\tt Get(-|-)} types \footnote{ Desiderata: We could like to race on handles or any blocking call. Current compiler support is for {\tt Put}.}. 
The system waits for input on any of the racing channels and triggers the corresponding continuation for the first one to receive data. The continuations for the losing channels are discarded.

In Example ??,

\subsection{Higher-order message passing using {\tt store} and {\tt use}}

CaMPL supports higher-order processes, that is, allowing {\em process}es to be packaged and passed to other processes, thereby treating processes as ``first-class citizens".  It provides two constructs for this purpose, namely,  
\begin{itemize}
	\item {\tt store} converts a concurrent process into sequential data.
	\item {\tt use} allow the calling of a stored process.
\end{itemize}
CaMPL provides a sequential data type {\tt Store}$(\Phi|\Lambda \vvdash \Delta)$ to represent stored processes. The following program demonstrates higher-order message passing using the Store type and the constructs. Process {\tt q} calls the stored process {\tt p}, {\tt counter} number of times.
\begin{center}
	\begin{varwidth}{\linewidth}
		\begin{verbatim}
			proc q :: Int, Store( | A => A) | A => A = 
					   counter, stored_process | a1 => a2 -> 
					       case counter of 
						       0 -> x |=| y						                    -- base	case
						       _ -> plug 					                       -- recursive case
							         use(stored_process)(| x => z)				               -- using the stored process
							         q(counter-1, p | z => y)		         -- recurse
		\end{verbatim}
	\end{varwidth}
\end{center}
The mathematics semantics of storing concurrent processes as sequential data is given by the equivalence between a right $\A$-actegory with Hom-objects and a right $\A$-enriched category with copowers, see \cite{Melika25}.

Another method of passing a process {\tt p} of type "{\tt | A => B}" to a process {\tt q} is using the channel type {\tt Neg(A) (+) B}. The channel type {\tt Neg(A) (+) B} encodes a process {\tt p} of type signature "{\tt | A => B}". Then, a process may "apply" the channel type "{\tt Neg(A) (+) B}" to a input channel of type {\tt A} to produce a output channel of type {\tt B}. The following code demonstrates this. 
\begin{center}
	\begin{varwidth}{\linewidth}
		\begin{verbatim}
			proc apply :: | A, Neg(A) (+) B => B =
				 | a, neg_a_b => b ->
				        fork neg_a_b as
				               neg_a -> neg_a |=| neg(a)
				               b' -> b |=| b' 
		\end{verbatim}
	\end{varwidth}
\end{center}
However, this method does not support arbitrary recursive definitions since channels are linear resources, hence cannot be duplicated (thereby disallowing multiple invocations of a received process). For example, consider a process {\tt q} that receives two input channels: one of type {\tt A} and another of type {\tt Neg(A) (+) A} (representing a process with type signature {\tt A => A}). Additionally, the process {\tt q} has a output channel of type {\tt A} and a sequential {\tt counter} of type {\tt Int}. The goal is to apply the input process to the input channel {\tt counter} times  possibly using the below code snippet. However, this code snippet is invalid in CaMPL since process {\tt q} uses the channel {\tt p} more than once , thereby, violating linearity constraint. 
\begin{center}
	\begin{varwidth}{\linewidth}
		\begin{verbatim}
			proc q :: Int | A, Neg(A) (+) A => A =
				 counter | a, p => y -> case counter of
				          0 -> a |=| y
				          _ -> plug
				          	     apply ( a, p => z )
					               q( counter - 1 | z, p => y )
		\end{verbatim}
	\end{varwidth}
\end{center}


Note that the above method for higher-order message passing behavior is implicit to CaMPL and uses no new instructions. This is due to the fact that the concurrent side of MPL is a $*$-autonomous category. This allows the language to inherently support (non-recursive) higher-order behavior as described by the following sequent rule,
\[ 
	\infer{\Lambda \vvdash A^\perp \oplus B := A \lollipop B}{\Lambda, A \vvdash B}
\]

\section{Interacting with the outside world via service channels}
	
\section{Sequential types}
	
	
\section{Example programs}

In all the examples, the processes interact with the outside world using two special channels ---  a protocol called {\tt StringTerminal} and a coprotocol {\tt Console} --- which are hard-coded in the compiler. 
\begin{itemize}
	\item The {\tt Console} type channels allow communication with the outside world via the console in which the campl program is executed. The console coprotocol provides handles {\tt ConsolePut}, {\tt ConsoleGet}, and {\tt ConsoleClose} which is used to send string, receive string from console, and to close console respectively. 
	
	\item Each {\tt StringTerminal} channel, on the other hand, is connected to an {\em Alacritty}\footnote{https://alacritty.org/} terminal process, and allows reading and writing to the terminal. 
\end{itemize}
  
Both the special (co)protocol declarations are available in the Prelude file, see Appendix \ref{prog:prelude}.

\subsection{Hello World}
\label{sec:Hello World}

In this example, we demonstrate a CaMPL process printing ``Hello World" on the console via an input channel named {\tt console}. The console is a special coprotocol channel hard-coded in the compiler which connects to the  terminal from which the program is run.
\begin{center}
	\begin{varwidth}{\linewidth}
		\begin{verbatim}
			1. proc helloworld :: | Console => = 
			2.    | console => -> do
			3.        hput ConsolePut on console              
			4.        put "Hello World" on console.      -- sends message to the console        
			
			5.        hput ConsoleClose on console       
			6.        halt console	                      -- closes console channel and halts               
		\end{verbatim}
	\end{varwidth}
\end{center}
The {\tt helloworld} process is invoked as follows:
\begin{center}
	\begin{varwidth}{\linewidth}
		\begin{verbatim}
			1. proc run = 
			2.    | console => -> helloworld( |console=>)  -- create a process helloworld
		\end{verbatim}
	\end{varwidth}
\end{center}

A sample output from the console is as follows:
\begin{center}
\begin{varwidth}{\linewidth}
	\begin{verbatim}
		> campl helloWorld.mpl 
			 Hello World
	 >
	\end{verbatim}
\end{varwidth}
\end{center}
	

\subsection{GetUntil}		   
This example extends the "Hello World" example by reading input from the console and printing it to the console. In this example, a process named {\tt getSomethingUntil} reads an input string from the console recursively and prints it (on the console). When the user enters the string {\tt q}, the process halts.

Reading an input string uses {\tt ConsoleGet} handle while printing the string uses {\tt ConsolePut} handle. The code for the process is as follows:
\begin{center}
	\begin{varwidth}{\linewidth}
		\begin{verbatim}
			1. proc getSomethingUntil :: | Console =>  = 
			2.    | console => -> do 
			3.        on console do
			4.            hput ConsolePut 
			5.            put "Enter any string (Enter q to exit)" 
			
			6.            hput ConsoleGet 
			7.            get input
			
			8.        case isExit(input) of 
			9.            True -> do 
			10.                on console do 
			11.                    hput ConsolePut 
			12.                    put "Exiting..." 
			13.                    hput ConsoleClose
			14.                    halt  
			15.            False -> do 
			16.                on console do 
			17.                    hput ConsolePut 
			18.                    put ("I received " ++ input) 
			19.                getSomethingUntil( | console => )   --recursive call
		\end{verbatim}
	\end{varwidth}
\end{center}

The {\tt getSomethingUntil} process is invoked as follows:
\begin{center}
	\begin{varwidth}{\linewidth}
		\begin{verbatim}
			1. proc run = 
			2.    | console => -> getSomethingUntil( | console => )
		\end{verbatim}
	\end{varwidth}
\end{center}	

Full version of the program is available in Appendix \ref{prog:getUntil}. A sample output from the console is as follows:
\begin{center}
\begin{varwidth}{\linewidth}
	\begin{verbatim}
		> campl getUntil.mpl 
			 Enter any string (Enter q to exit)
			 Apple
			 I received Apple
			 Enter any string (Enter q to exit)
			 Orange
			 I received Orange
			 Enter any string (Enter q to exit)
			 q
			 Exiting...
		>
	\end{verbatim}
\end{varwidth}
\end{center}

\subsection{Simple EchoServer}
The examples so far demonstrated communication between a process and the outside world via the console. In this example, we have two user-defined processes -- a client and a server. A client reads input string from the terminal, and sends it to the server. The server on listens to the client and on receiving an input string, it prints it to the console. When the user enters {\tt q}, the client and the server halt.
\[ \includegraphics[scale=0.08]{figs/echo-topology.jpeg} \]

The processes use \texttt{Echo} protocol for communication. It provides a handle \texttt{EchoSend} which constructs a channel of {\tt Put( [Char] | S} type. A channel of {\tt Put( [Char] | S)} type means that a process may send/receive a message of type {\tt [Char]} over this channel after which the channel becomes of type {\tt S}. The handle \texttt{EchoClosed} is used to close a channel of \texttt{Echo} type. 

\begin{center}
	\begin{varwidth}{\linewidth}
		\begin{verbatim}
			1. protocol Echo => S =
			2.    EchoSend :: Put( [Char] | S)) => S
			3.    EchoClose :: TopBot => S
		\end{verbatim}
	\end{varwidth}
\end{center}

The main process creates a client and a server process as follows which are plugged together by a channel:
\begin{center}
	\begin{varwidth}{\linewidth}
		\begin{verbatim}
			1. proc run = 
			2.    | console => term -> plug 
			3.        client( | => ch, term )
			4.        server( | ch, console => )
		\end{verbatim}
	\end{varwidth}
\end{center}	

The client process is connected to an output channel of type \texttt{Echo}. It first reads a string (provided by the user) from the terminal. If the input string is not {\tt q}, then the client will place the \texttt{EchoSend} handle on the channel and \texttt{put} the string. Otherwise, it will place the \texttt{EchoClose} handle on the channel and halt.

\begin{center}
	\begin{varwidth}{\linewidth}
		\begin{verbatim}
			1. proc client :: | => Echo, StringTerminal =
			2.    | => ch, term -> do
			3.        on term do 
			4.            hput StringTerminalPut 
			5.            put "Enter any string (Enter q to exit)" 
			6.            hput StringTerminalGet 
			7.            get input 
			
			8.        case isExit(input) of 
			9.            True -> do                               
			10.                on term do 
			11.                    hput StringTerminalClose
			12.                    close 
			13.                on ch do 
			14.                    hput EchoClose
			15.                    halt 
			16.            False -> do                             
			17.                on ch do 
			18.                    hput EchoSend 
			19.                    put input 
			20.                client( |  => ch, term )            -- recursion
		\end{verbatim}
	\end{varwidth}
\end{center}

The server process is connected to an input channel of type \texttt{Echo}. It first listens to handles from the client using \texttt{hcase}. If the handle received is \texttt{EchoSend}, then it receives data (sent by the client) using \texttt{get}. If the handle received is \texttt{EchoClose} then it closes it connection with the channel and halts. 
\begin{center}
	\begin{varwidth}{\linewidth}
		\begin{verbatim}
			1. proc server :: | Echo, Console => =
			2.    | ch, console => -> do
			3.        hcase ch of
			4.            EchoSend -> do
			5.                get input on ch 
			6.                on console do
			7.                    hput ConsolePut 
			8.                    put ("I received " ++ input) 
			
			9.                server( | ch, console => )                 
			10.            EchoClose -> do
			11.                on console do 
			12.                    hput ConsolePut
			13.                    put "Done"
			14.                    hput ConsoleClose
			15.                    close 
			16.                halt ch
		\end{verbatim}
	\end{varwidth}
\end{center}	

A full version of the program is available in Appendix \ref{prog:echo}. A sample output is shown below. The screenshot shows the client terminal. The server output on the console is as follows:-
\begin{center}
\begin{varwidth}{\linewidth}
	\begin{verbatim}
		> campl echoServer.mpl 
		  I received Apple
		  I received Orange
		  Done
	\end{verbatim}
\end{varwidth}
\end{center}
\[ \includegraphics[scale=0.5]{figs/echo-server.png} \]

\subsection{Echo Server 2.0: Non-deterministic communication}

This example demonstrates two clients racing to send a message to an echo server. The server prints the messages in the order it receives those messages. The server halts after printing both the messages. The clients halt as soon as they send. 
\[ \includegraphics[scale=0.1]{figs/non-det.jpeg} \]

The {\tt run} process initiates two clients tagged by {\tt"1"} and {\tt"2"} and a server:

\begin{center}
\begin{varwidth}{\linewidth}
	\begin{verbatim}
		1. proc run :: | Console => StringTerminal, StringTerminal =
		2.    | console => term1, term2 -> plug
		3.        client("1:"| => ch1, term1 )
		4.        client("2:"| => ch2, term2)
		5.        server( |ch1, ch2, console => )
	\end{verbatim}
\end{varwidth}
\end{center}	

The server sets up a race between the client processes using {\tt race} command. When one of the client wins, it calls a helper process to receive message from the winning client. The server has two input channels of type {\tt Put([Char] | TopBot)} --- this means that the server may {\tt get} a message of {\tt [Char]} type over this channel after which the channel becomes of the type {\tt TopBot}.

\begin{center}
\begin{varwidth}{\linewidth}
	\begin{verbatim}
		1. proc server :: | Put([Char] | TopBot), Put([Char] | TopBot), Console => =
		2.    | ch1, ch2, console => -> race
		3.        ch1 -> do
		4.            receive_message_and_continue( | ch1, ch2, console => )
		5.        ch2 -> do 
		6.            receive_message_and_continue( | ch2, ch1, console => )
	\end{verbatim}
\end{varwidth}
\end{center}	

When one of the clients win the race, the server invokes a helper process to get message from the winning client, to outputs the message on the console, and to then get message from the losing client, and output the message on the console.

\begin{center}
\begin{varwidth}{\linewidth}
	\begin{verbatim}
		1. proc receive_message_and_continue :: 
		2.	| Put([Char] | TopBot), Put([Char] | TopBot), Console => = 
		3.    | winner, loser, console => -> do
		4.        get message on winner
		5.        hput ConsolePut on console
		6.        put message on console
		7.        close winner 
		
		8.        get message on loser
		9.        hput ConsolePut on console
		10.        put message on console
		11.        close loser  
		
		12.        on console do
		13.            hput ConsolePut 
		14.            put "Done. Halting server."   
		15.            hput ConsoleClose
		16.            halt
	\end{verbatim}
\end{varwidth}
\end{center}	

Each client is connected to its own StringTerminal. When a client receives an input from user in its terminal, it sends it to the server.

\begin{center}
\begin{varwidth}{\linewidth}
	\begin{verbatim}
		1. proc client :: [Char] | => Put( [Char] | TopBot), StringTerminal =
		2.    tag | => ch, term -> do
		3.        on term do
		4.            hput StringTerminalPut
		5.            put tag ++ "Input a string"
		6.            hput StringTerminalGet
		7.            get message
		
		8.        on ch do
		9.            put tag ++ message
		10.            close
		
		11.        on term do 
		12.            hput StringTerminalClose
		13.            halt 
	\end{verbatim}
\end{varwidth}
\end{center}	

A full version of the program is available in Appendix \ref{prog:EchoServer-2.0}. When the program is run, it opens two Alacrity windows (one for each client tagged by client number) waiting for input from user. 
\[ \includegraphics[scale=0.45]{figs/race-output.PNG}\]

\subsection{Echo Server 3.0: Higher-order message passing}

In this extended example, we demonstrate higher-order message passing, that is, how a process can be encoded as a message and sent to another process, which can then decodes the message and runs the process it has received.

In this example, we will encode {\tt proc helloworld} from Section \ref{sec:Hello World} into a sequential message. A client process sends this message to its server, which then runs the {\tt Hello World}.

The main process creates a {\tt client} and a {\tt server} process. 
\begin{center}
\begin{varwidth}{\linewidth}
	\begin{verbatim}
		1. proc run = 
		2.    | console =>  -> plug 
		3.        client( | => ch )
		4.        server( | ch, console => )
	\end{verbatim}
\end{varwidth}
\end{center}
The {\tt client} process has an output channel of type {\tt Put( Store(|Console=>) | TopBot}, that the client can send a sequential type {\tt Store(|Console=>)} over this channel using {\tt put} command after which the channel assumes the type {\tt TopBot}. Recall that only channels of {\tt TopBot} type can be {\tt close}d or {\tt halt}ed. The sequential type {\tt Store(|Console=>)} refers to the encoding of a process with type signature {\tt ( |Console=> )}, that is the process has a single output channel of type {\tt Console}.

\begin{center}
\begin{varwidth}{\linewidth}
	\begin{verbatim}
		1. proc client :: | => Put( Store( | Console => ) | TopBot  ) =
		2.    | => ch -> do
		3.        on ch do 
		4.            put store(hello_world) 
		5.            halt
	\end{verbatim}
\end{varwidth}
\end{center}

The {\tt server} process has two input channels of type {\tt Put(Store(|Console =>)| TopBot)} and {\tt Console}. The server and the client are plugged via the {\tt Put} type channel. The server receives the stored process, in this case, {\tt helloworld}, over channel {\tt ch} and closes {\tt ch}. In its last line of 4, it invokes the {\tt stored\_process} with required arguments using the {\tt use} command.

\begin{center}
\begin{varwidth}{\linewidth}
	\begin{verbatim}
		1. proc server :: | Put( Store( | Console => ) | TopBot  ), Console => =
		2.    | ch, console => -> do
		3.        on ch do
		4.            get stored_process 
		5.            close 
		
		6.        on console do 
		7.            hput ConsolePut 
		8.            put ("Server says: Running the stored process")
		        
		9.        use(stored_process)( | console => )
	\end{verbatim}
\end{varwidth}
\end{center}

On running the program, the {\tt server} and the {\tt helloworld} prints the following message on the console:
\begin{center}
\begin{varwidth}{\linewidth}
	\begin{verbatim}
		> campl echoServer-higher-order.mpl 
		  Server says: Running the stored process
		  Stored process says: Hello World
	\end{verbatim}
\end{varwidth}
\end{center}
	
Full version of the program is available in Appendix \ref{appendix: stored process example}.

\subsection{Memory Cell: Mutual Exclusive access of shared memory}

This example simulates mutual exclusive access of a memory cell between two CaMPL processes tagged {\tt "A"} and {\tt "B"}. The example uses {\tt fork} and {\tt split} to pass a {\tt Mutex} channel type. The {\tt fork} creates new processes are created during program execution.

\[ \includegraphics[scale=0.1]{figs/MemCell.jpeg} \] 

The code primarily has three processes:- 
\begin{enumerate}
	\item a process {\tt memAccess} which reads and writes to the memory, 
	\item a process {\tt memWait}, and a Memory cell process, and 
	\item a process {\tt memCell}, which is the memory cell.
\end{enumerate}

Process {\tt memAccess} is connected to {\tt memCell} via an output channel using {\tt MemCh} protocol, defined as follows. The protocol provides to read, write and close a memory cell.
\begin{center}
\begin{varwidth}{\linewidth}
	\begin{verbatim}
		1. protocol MemCh (A | ) => S =
		2.     MemPut :: Put(A|S) => S
		3.     MemGet :: Get(A|S) => S
		4.     MemCls :: TopBot => S
			\end{verbatim}
\end{varwidth}
\end{center}

{\tt Mutex} protocol is used communication for between the {\tt MemWait} (at output end) and {\tt MemAccess} processes (at input end). 
\begin{center}
\begin{varwidth}{\linewidth}
	\begin{verbatim}
		1. protocol Mutex( | M ) => S =
		2.    Pass :: M (+) Neg(S)  => S
	\end{verbatim}
\end{varwidth}
\end{center}
The {\tt Neg} type is used to convert an input {\tt Mutex} channel into an output {\tt Mutex} channel, and vice versa. For example, {\tt memAccess} uses the {\tt Neg} type to convert an input {\tt Mutex} channel into an output {\tt Mutex} channel, and invoke {\tt memWait} using the converted type. 

The program begins execution with the main process defined as follows:-
\begin{center}
\begin{varwidth}{\linewidth}
	\begin{verbatim}
		1. proc run =
		2.    | => _strterm0, _strterm1 -> do
		3.        plug 
		4.            memAccess("A:" | mutex => mem, _strterm0)
		5.            memWait("B:" |        => mutex, _strterm1)
		6.            memCell( "I like dogs" | mem => )
	\end{verbatim}
\end{varwidth}
\end{center}
We have two processes named {\tt "A"} and {\tt "B"} competing to access the memory cell. Each of these processes access a string terminal to read user input which is stored in memory. To begin with Process {\tt A} starts by running {\tt memAccess} and process {\tt B} starts by running {\tt memWait}.

{\tt memWait} and {\tt memAccess} are mutually recursive processes. The process running {\tt memAccess} calls {\tt memWait} (once the read/write is complete), and vice versa.

{\tt memWait} sends {\tt Pass} handle over {\tt mutex} to {\tt memAccess}. On receiving the handle, {\tt memAccess} reads and writes to the memory over the {\tt mem} channel. Once it completes, it forks over the {\tt mutex} channel and invokes {\tt memWait} using {\tt plug}. The input {\tt Neg(Mutex)} needs to be negated to get an output {\tt Mutex} channel type, which is then used in the invocation of {\tt memWait}.

\begin{center}
\begin{varwidth}{\linewidth}
	\begin{verbatim}
    1. proc memAccess :: [Char] | Mutex( | MemCh([Char] | ) ) 
    2.	=> MemCh([Char]| ), StringTerminal =
    3.    tag | mutex => mem, _strterm -> hcase mutex of 
    4.        Pass -> do 
    5.            hput MemGet on mem
    6.            get inp on mem

    7.            hput StringTerminalPut on _strterm
    8.            put append(tag, " Receiving: ") on _strterm

    9.            hput StringTerminalPut on _strterm
    10.            put inp on _strterm

    11.            hput StringTerminalPut on _strterm
    12.            put append(tag, " Enter a string: ") on _strterm

    13.            hput StringTerminalGet on _strterm
    14.            get ninp on _strterm

    15.            hput MemPut on mem
    16.            put ninp on mem

    17.            fork mutex as
    18.                mmem with mem -> mmem |=| mem

    19.                negmutex with _strterm -> do
    20.                    plug
    21.                        memWait(tag | => nmutex, _strterm)
    22.                        nmutex, negmutex => -> negmutex |=| neg nmutex
	\end{verbatim}
\end{varwidth}
\end{center}





%The protocol {\tt Mutex} has an input channel type {\tt M} and an output channel type {\tt S}. The handle {\tt Pass} type constructs from {\tt S} a compound {\tt (+)} type channel. The protocol {\tt MemCh} is used communication between {\tt MemAccess} and Memory cell for reading, writing and closing a memory cell.

Process {\tt memWait} activates the {\tt mutex} channel by sending {\tt Pass} handle over it. Then it blocks itself using {\tt split} command. When {\tt memAccess} executes {\tt fork} command, the {\tt memWait} is unblocked and invokes {\tt memAccess} using {\tt plug}. The output {\tt Neg(Mutex)} needs to be negated to get an input {\tt Mutex} channel.
\begin{center}
\begin{varwidth}{\linewidth}
	 \begin{verbatim}
	1.    proc memWait :: [Char] |  => Mutex( | MemCh([Char] | )), StringTerminal =
	2.        tag | => mutex, _strterm -> do
	3.            hput Pass on mutex
	4.            split mutex into mem, negmutex
	
	5.            plug
	6.                memAccess(tag | nmutex => mem, _strterm)
	7.                => negmutex, nmutex -> negmutex |=| neg nmutex
	\end{verbatim}
\end{varwidth}
\end{center}

The process {\tt memCell} takes an input {\tt MemCh} channel, reads and writes to it.
\begin{center}
\begin{varwidth}{\linewidth}
	\begin{verbatim}
	1.	proc memCell :: A | MemCh(A | ) => =
	2.	    val | ch => -> hcase ch of
	3.	        MemPut -> do
	4.	            get nval on ch
	5.	            memCell(nval | ch => )
	6. 	        MemGet -> do
	7.	            put val on ch
	8.	            memCell(val | ch => )
	9.	        MemCls -> do
	10.	            halt ch
	\end{verbatim}
\end{varwidth}
\end{center}

The full version of the code is available in Appendix \ref{prog:mem-cell}. A screenshot of the output is given below. To begin with process {\tt A} reads ``I like dogs" from the memory cell and writes ``Apple" to the memory cell. Process  {\tt B} reads ``Apple" from memory cell and writes ``Orange" to it. Process then {\tt A} reads ``Orange" from the memory cell.
\[ \includegraphics[scale=0.35]{figs/memcell-output.png} \]

\section{Notes on the compiler and interface design}

CaMPL has concurrent and sequential types. Some useful tables and notes.

The following table summarizes the analogues of sequential and concurrent worlds.

\begin{center}
\begin{tabular}{ c | c | c | c }
 {\bf Sequential} & Datatypes  & Functions & Instances \\ 
   & (and coDatatypes)  &  &  \\
 \hline
 {\bf Concurrent} & Protocols & Processes & Channels \\  
 & (and coProtocols)  &  &  \\
\end{tabular}
\end{center}

Channels are instances of (co)protocols. Given a process and a channel {\em connected} to it, the channel may have input (+) or output polarity (-) for that process. 

Here are a few practical programming notes:
\begin{itemize}
	\item {\tt close} command closes a channel. {\tt halt} command is used on a process which has only one connected channel. Halt closes the channel and halts the process. 
	
	{\bf Design question:} Why not interpret closing all the channels as a signal to halt? For example: 
	\begin{verbatim}
		 close ch1  
		 close ch2  
		 halt
	\end{verbatim}
	
	\item The handles \tt{ConsoleGet}, \tt{ConsolePut}, \tt{ConsoleClose}, \tt{StringTerminalGet}, \tt{StringTerminalPut}, and \tt{StringTerminalClose} which are used for reading from and writing to terminals are hard-coded.  
	
\begin{center}
	\begin{tabular}{ c | c | c }
		     (P)       & (+) & (-) \\
		 \hline      
		 {\tt Get}  & {\tt get}  & {\tt put} \\
		 \hline
		 {\tt Put}  & {\tt put}  & {\tt get} 
	\end{tabular}
	\quad \quad 
	\begin{tabular}{ c | c | c }
		     (coP)       & (+) & (-) \\
		 \hline      
		 {\tt Get}  & {\tt put}  & {\tt get} \\
		 \hline
		 {\tt Put}  & {\tt get}  & {\tt put} 
	\end{tabular}
	\quad \quad 
	\begin{tabular}{ c | c | c }
		            & (+) & (-) \\
		 \hline      
		 (P)  & {\tt hput}  & {\tt hcase} \\
		 \hline
		 (coP)  & {\tt hcase}  & {\tt hput} 
	\end{tabular}
\end{center}
 
\end{itemize}

The following items were suggested by Hashimoto as improvements to CaMPL syntax:

\begin{itemize}
	\item While we have \texttt{Get} and \texttt{Put} for protocols (which means get and put on the output polarity), it will be user-friendly \texttt{coGet} and \texttt{coPut} for coprotocols (to mean \texttt{put} and \texttt{get} respectively on the output terminal.
	\item Racing on handles instead of \texttt{put}. So be able to race on \texttt{hput}, and \texttt{fork} handles.
	\item Merge the \texttt{hput} followed by the get or put. 
	\item \texttt{on <channel> hput <handle>} instead of \texttt{hput <handle> on <channel>}. 
	\item Currently, to halt a process, the channels are first closed and the final \texttt{halt <channel>} command takes in the name of the last channel to be closed. Instead, close all the channels followed by \texttt{halt} command.
\end{itemize}


\section{Mathematical Underpinning}

The semantics of the concurrent side of CaMPL is given by a linearly distributive category whose objects are interpreted as concurrent channel types and maps as processes between channels. 

\subsection{Category Theory}

The mathematical semantics of CaMPL is modeled by a {\em linear actegory} \cite{CoP07}:4.2 where a symmetric monoidal categorical category $\X$ --- representing the semantics of of the sequential side --- acts on a symmetric linearly distributive category $\C$ --- representing the semantics of the concurrent side. This interaction is defined by two action functors:

\[ \circ: \A \times \C \to \C \quad \quad \text{ and } \quad \quad \bullet: \A^{\sf op} \times \C \to \C \]

These functors describe how sequential data, or {\em messages}, are transmitted through {\em channels}, which are modeled as concurrent types. The $\circ$ functor is the left parametrized left adjoint of $\bullet$ in the sense that the following is a parametrized adjunction:

\[ A \in \A,  \quad X \circ - \dashv A \bullet - : \C \to \C \]

The adjunction signifies that a process transmitting or receiving a message can do so from either end of a channel. 

\subsection{Message Passing Logic}

The message passing logic, {\bf Msg}, gives a type system for concurrent proccesses which use message passing as their concurrency primitive \cite{CoP07}. The logic they introduced is two-tiered with rules governing the interaction of the two tiers. The two-tiers include the logic of messages and logic of message-passing.

\subsubsection{The logic of messages}

This tier concerned with generation of messages represents the logic of computation, and corresponds to the type system for sequential computation. The proofs in this logic correspond to sequential programs. The logic is presented in a Gentzen sequent style: a sequent takes the form
\[ \Phi \vdash A \]
where the {\em antecedent} (which we will also call the {\em context}) of $\Phi$ is a comma-separated list of formulas and the {\em succedent} $A$ is a single formula. The term calculus for this logic is given in Figure \ref{Fig:MsgRules}. In the inference rules, {\em subs} stands for substitution and is the cut rule. 

\begin{figure}
\centering
	\includegraphics[scale=0.5]{figs/MsgRules.PNG}
	\caption{Inference rules for {\bf Msg}}
	\label{Fig:MsgRules}
\end{figure}

\subsubsection{The logic of message-passing}
	
	The logic of message, {\bf PMsg}, passing concerned with communication over channels represents the logic of communication, and is concerned with channels over which processes communicate messages. A sequent of {\bf PMsg} has three components all of which are unordered lists: list $\Phi$ of message types, list $\Lambda$ of left polarity channels, and list $\Delta$ of right polarity channels which, together define a sequent of PMsg: 
\[ \Phi ~|~ \Lambda \vvdash \Delta \]	
The inference rules for {\bf PMsg} are presented in Figure \ref{Fig:PMsgRules}. Most of the rules of this calculus are standard ones for two-sided multiplicative linear logic except the {\em action} rules $\circ_l$, $\circ_r$, $\bullet_l$, and $\bullet_r$ which allow messages to be bound to channels of interaction.
\begin{figure}
\centering
	\includegraphics[scale=0.6]{figs/PMsgRules.PNG}
	\caption{Inference rules for {\bf PMsg}}
	\label{Fig:PMsgRules}
\end{figure}
	
Thus, the message passing logic provides a clean separation of computation and communication layers thereby allowing the complexities associated with each layer to be addressed effectively. Figure \ref{Fig:programming-syntax} provides the programming syntax for CaMPL.
\begin{figure}
\centering
	\includegraphics[scale=0.6]{figs/programming-syntax.png}
	\caption{Programming syntax for {\bf PMsg}}
	\label{Fig:programming-syntax}
\end{figure}


\begin{appendix}
\section{Examples: Complete programs}

\subsection{Prelude}
\label{prog:prelude}

\textcolor{red}{Todo: Add Prelude file.}

\subsection{Get Until}
\label{prog:getUntil}
\begin{center}
\begin{varwidth}{\linewidth}
	\begin{verbatim}
	include Prelude 
	
	fun isExit :: [Char] -> Bool = 
	    [] -> False
	    x:xs -> if x == 'q' then True else False
	
	proc getSomethingUntil :: | Console =>  = 
	    | console => -> do 
	        on console do
	            hput ConsolePut 
	            put "Enter any string (Enter q to exit)" 
	
	            hput ConsoleGet 
	            get input
	
	        case isExit(input) of 
	            True -> do 
	                on console do 
	                    hput ConsolePut 
	                    put "Exiting..." 
	                    hput ConsoleClose
	                    halt  
	            False -> do 
	                on console do 
	                    hput ConsolePut 
	                    put ("I received " ++ input) 
	                getSomethingUntil( | console => )
	
	proc run = 
	    | console =>  -> getSomethingUntil( | console => )	
	
	\end{verbatim}
\end{varwidth}
	------
\end{center}
\newpage

\subsection{Simple Echo Server}
\label{prog:echo}

\begin{center}
	\begin{Verbatim}
	include Prelude 
	
	fun isExit :: [Char] -> Bool = 
	    [] -> False
	    x:xs -> if x == 'q' then True else False
	
	protocol Echo => S =
	    EchoSend :: Put( [Char] | S) => S
	    EchoClose :: TopBot => S
	
	proc client :: | => Echo, StringTerminal =
	    | => ch, term -> do
	        on term do 
	            hput StringTerminalPut 
	            put "Enter any string (Enter q to exit)" 
	            hput StringTerminalGet 
	            get input 
	
	        case isExit(input) of 
	            True -> do 
	                on term do 
	                    hput StringTerminalClose
	                    close 
	                on ch do 
	                    hput EchoClose
	                    halt 
	            False -> do 
	                on ch do 
	                    hput EchoSend 
	                    put input 
	                client( |  => ch, term )
	                
	proc server :: | Echo, Console => =
	    | ch, console => -> do
	        hcase ch of
	            EchoSend -> do
	                get input on ch 
	                on console do
	                    hput ConsolePut 
	                    put ("I received " ++ input) 
	
	                server( | ch, console => )                 
	            EchoClose -> do
	                on console do 
	                    hput ConsolePut
	                    put "Done"
	                    hput ConsoleClose
	                    close 
	                halt ch
	
	proc run = 
	    | console => term -> plug 
	        client( | => ch, term )
	        server( | ch, console => )
	\end{Verbatim}
		------
\end{center}

\newpage

\subsection{EchoServer 2.0}
\label{prog:EchoServer-2.0}

\begin{center}
	\begin{Verbatim}
		include Prelude
		
		proc client :: [Char] | => Put( [Char] | TopBot), StringTerminal =
		    tag | => ch, term -> do
		        on term do
		            hput StringTerminalPut
		            put tag ++ "Input a string"
		            hput StringTerminalGet
		            get message
		
		        on ch do
		            put tag ++ message
		            close
		
		        on term do 
		            hput StringTerminalClose
		            halt 
		
		proc receive_message_and_continue :: | Put([Char] | TopBot), 
		Put([Char] | TopBot), Console => = 
		    | winner, loser, console => -> do
		        get message on winner
		        hput ConsolePut on console
		        put message on console
		        close winner 
		
		        get message on loser
		        hput ConsolePut on console
		        put message on console
		        close loser  
		
		        on console do
		            hput ConsolePut 
		            put "Done. Halting server."   
		            hput ConsoleClose
		            halt
		                       
		proc server :: | Put([Char] | TopBot), Put([Char] | TopBot), Console => =
		    | ch1, ch2, console => -> race
		        ch1 -> do
		            receive_message_and_continue( | ch1, ch2, console => )
		        ch2 -> do 
		            receive_message_and_continue( | ch2, ch1, console => )
		
		proc run :: | Console => StringTerminal, StringTerminal =
		    | console => term1, term2 -> plug
		        client("1:"| => ch1, term1 )
		        client("2:"| => ch2, term2)
		        server( |ch1, ch2, console => )
	\end{Verbatim}
	------
\end{center}
\newpage 

\subsection{EchoServer 3.0}
\label{appendix: stored process example}

\begin{center}
	\begin{Verbatim}
		include Prelude
		
		proc hello_world :: | Console =>  =
		     | console =>  ->  do 
		        on console do 
		            hput ConsolePut
		            put "Stored process says: Hello World "
		            hput ConsoleClose 
		            halt
		
		proc client :: | => Put( Store( | Console => ) | TopBot  ) =
		    | => ch -> do
		        on ch do 
		            put store(hello_world) 
		            halt
		
		proc server :: | Put( Store( | Console => ) | TopBot  ), Console => =
		    | ch, console => -> do
		        on ch do
		            get stored_process 
		            close 
		
		        on console do 
		            hput ConsolePut 
		            put ("Server says: Running the stored process")
		        
		        use(stored_process)( | console => )
		
		proc run = 
		    | console =>  -> plug 
		        client( | => ch )
		        server( | ch, console => )
	\end{Verbatim}
		------
\end{center}
\newpage

\subsection{Memory Cell}
\label{prog:mem-cell}
\begin{center}
	\begin{Verbatim}
		include Prelude
		
		protocol StringTerminal => S =
		    StringTerminalGet :: Get( [Char] | S) => S 
		    StringTerminalPut :: Put( [Char] | S) => S
		    StringTerminalClose :: TopBot => S
		
		protocol Mutex( | M ) => S =
		    Pass :: M (+) Neg(S)  => S
		
		protocol MemCh (A | ) => S =
		    MemPut :: Put(A|S) => S
		    MemGet :: Get(A|S) => S
		    MemCls :: TopBot => S
		
		fun append :: [A], [A] -> [A] =
		    [], ts -> ts
		    s:ss, ts -> s : append(ss,ts)
		
		proc memCell :: A | MemCh(A | ) => =
		    val | ch => -> hcase ch of
		        MemPut -> do
		            get nval on ch
		            memCell(nval | ch => )
		        MemGet -> do
		            put val on ch
		            memCell(val | ch => )
		        MemCls -> do
		            halt ch

		defn
		    proc memAccess :: [Char] | Mutex( | MemCh([Char] | ) ) 
		    => MemCh([Char]| ), StringTerminal =
		        tag | mutex => mem, _strterm -> hcase mutex of 
		            Pass -> do 
		                hput MemGet on mem
		                get inp on mem
		
		                on _strterm do 
		                    hput StringTerminalPut
		                    put (tag++ " Receiving: ")
		
		                    hput StringTerminalPut
		                    put inp
		
		                    hput StringTerminalPut
		                    put append(tag, " Enter a string: ")
		
		                    hput StringTerminalGet
		                    get ninp
		
		                hput MemPut on mem
		                put ninp on mem
		
		                fork mutex as
		                    mmem with mem -> mmem |=| mem
		
		                    negmutex with _strterm -> do
		                        plug
		                            memWait(tag | => nmutex, _strterm)
		                            nmutex, negmutex => -> negmutex |=| neg nmutex
		
		
		    proc memWait :: [Char] |  => Mutex( | MemCh([Char] | )), StringTerminal =
		        tag | => mutex, _strterm -> do
		            hput Pass on mutex
		            split mutex into mem, negmutex
		
		            plug
		                memAccess(tag | nmutex => mem, _strterm)
		                => negmutex, nmutex -> negmutex |=| neg nmutex
		                    
		proc run =
		    | => _strterm0, _strterm1 -> do
		        plug 
		            memAccess("A:" | mutex => mem, _strterm0)
		            memWait("B:" |        => mutex, _strterm1)
		            memCell( "I like dogs" | mem => )
	\end{Verbatim}
		------
\end{center}

\end{appendix}

\end{document}

DEPRECATED:

\subsection{EchoServer 2.0}

\subsection*{Expected program behavior} There are two processes {\em a client} and {\em a server} communicating with one another. The server is connected to the environment via a console, and the client via a \texttt{StringTerminal}. The server reads a string from the terminal, relays it to the server who prints it on the console, and sends the string back to the client. When the user provides an empty string, the processes terminate. 

The topology of the processes and their connection remains the same throughout the program. The topology is shown in the diagram below:
<DIAGRAM>


\subsection*{CaMPL program}
The main protocol used in this program is \texttt{Echo}. It provides a handle \texttt{EchoSend} of Put-Get type which will be used to send-receive or receive-send a message depending on the polarity of channel ends. The handle \texttt{EchoClosed} is used to close a channel of \texttt{Echo} type. 

\begin{verbatim}
protocol Echo => S =
    EchoSend :: Put( [Char] | Get( [Char] | S)) => S
    EchoClose :: TopBot => S
\end{verbatim}

The client process is connected to a channel of \texttt{Echo} type at the output end. It first reads a string (provided by the user) from the terminal. If the user provided a non-empty string, it will place \texttt{EchoSend} handle on the channel followed by a \texttt{put} to send the string. Then, it performs a (blocking) \texttt{get} to receive data from server and loops. If the use provided an empty string, it signals the server by placing the \texttt{EchoClose} handle on the channel. It closes its connection and terminates.

\begin{verbatim}

proc client :: | => Echo, ClientConsole =
    | => ch, console -> do
        hput StringTerminalGet on console
        get fruit on console

        case fruit of
            [] -> do
                hput EchoClose on ch
                hput StringTerminalClose on console
                close console
                halt ch

            _:_ -> do
                hput EchoSend on ch
                -- send data
                put fruit on ch 
                -- receive echoed data
                get echoed on ch  
                -- print received data
                hput StringTerminalPut on console
                put ('>':' ':echoed) on console

                -- loop
                client( | => ch, console)
\end{verbatim}    

The server process is connected to a channel of \texttt{Echo} type at the input end. It first performs a (blocking) \texttt{hcase}. If the handle received is \texttt{EchoSend}, then it receives data (sent by the client) using a {blocking} \texttt{get}. It sends the received data back as an acknowledgement using a \texttt{put} (since the handle \texttt{EchoSend} does Put-Get), and loops. If the handle received is \texttt{EchoClose} then it closes it connection with the channel and terminates. 

\begin{verbatim}
proc server :: | Echo, LogConsole => =
    | ch, console => -> do
        hcase ch of
            EchoSend -> do
                -- receive data
                get fruit on ch

                -- print data
                hput ConsolePut on console
                put fruit on console

                -- echo (send) data 
                put fruit on ch
                server( | ch, console => )
            EchoClose -> do
                hput ConsolePut on console
                put "Done" on console
                hput ConsoleClose on console
                close console
                halt ch
\end{verbatim}

The following is the code for ClientConsole and the server's LogConsole for reading input and printing output. 

\begin{verbatim}

protocol ClientConsole => S =
    StringTerminalGet :: Get( [Char] | S) => S
    StringTerminalPut :: Put( [Char] | S) => S
    StringTerminalClose :: TopBot => S

coprotocol S => LogConsole =
    ConsolePut :: S => Get( [Char] | S)
    ConsoleClose :: S => TopBot
\end{verbatim}

The following process  is the first process to be invoked by the program which initiates the topology, and runs the client and the server. 

\begin{verbatim}
proc run :: | LogConsole => ClientConsole =
    | console_s => console_c -> plug
        client( | => ch, console_c )
        server( | ch, console_s => )

\end{verbatim}

\section{Memory Cell}




