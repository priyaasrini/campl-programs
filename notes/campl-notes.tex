\documentclass[11pt]{article}
\input{preamble}
\input{macros}
\addbibresource{refs.bib}
\linespread{1.11}

\title{Categorical Message Passing Language (CaMPL)}
\author{
    Robin Cockett\thanks{University of Calgary} \and Daniel Hashimoto\thanks{Universidade Federal do Rio de Janeiro} \and Priyaa Varshinee Srinivasan\thanks{Tallinn University of Technology}}
%\def\authorrunning{D.\ I.\ Spivak \& P.\ V.\ Srinivasan}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
This document is a simple introduction to  a novel concurrent programming language called the 
categorical message passing language built on the mathematics of linear actegories. 
Categorical Message Passing Language, to the best of our knowledge, 
the only\footnote{Is this true?} concurrent programming language with mathematical underpinnings. 
It is a functional-style programming language with the abstract machine built on Haskell. 
The current version of CaMPL compiler is to be considered a proto-alpha, a proof-of-concept 
of a programming language built from the mathematics of linear actegories.
\end{abstract}

%\addcontentsline{toc}{section}{References}

\tableofcontents

\section{Introduction}

Explain current state of concurrency and why CaMPL is novel (Curry-Howard-Lambek-like correspondence), and its history.

\section{Sequential types}

\section{Concurrent types}

A semantics of the concurrent side of CaMPL is given by a linearly distributive category $\C$ which comes with two monoidal structures $\otimes$ (tensor) and $\oplus$ (par). In this category, objects are concurrent channel types and morphisms are processes between channels. 

\begin{center}
\begin{tabular}{ c ||  c | c | c }
 {\bf Sequential} & Functions & Datatypes   & Instances \\ 
   & & (and coDatatypes)   &  \\
 \hline
 {\bf Concurrent} & Processes & Protocols  & Channels \\  
 & & (and coProtocols)    &  \\
\end{tabular}
\end{center} 

At any instance in run-time, the topology of a CaMPL program, consists of a finite set of {\em processes} connected by {\em channels} arranged as an acyclic graph. 

\subsection{Processes}

A process comes with an optional list of:
\begin{itemize}
	\item data values (sequential input types),
	\item left polarity channels, and
	\item right polarity channels.
\end{itemize}
For example, the following code shows a process \texttt{p} with a sequential input of type $A$, a left polarity channel of type $X$, and a right polarity channel of type $Y$ as defined in CAMPL (Process \texttt{p} is connected to the right end of \texttt{x} and to the left end of {\tt y}). 

  \begin{center}
  \begin{varwidth}{\linewidth}
  \begin{verbatim}
  	proc p :: A | X => Y =
					a | x => y -> ...
  \end{verbatim}
  \end{varwidth}
  \end{center}
  
  \vspace{-1em}
  
  \[ \xymatrix{  
  \ar@{<-}[r]^{X~~~~}  & \quad \blackman  \quad \ar[r]^{~~~~Y} &    } \]
  
It can be equivalently expressed in the sequent calculus as:
$  A ~|~ X ~\dashvv~ Y $.  

\subsection{Channels}

In CaMPL, processes communicate (send and receive messages) via channels.

\subsection*{Built-in Channel types}

The following information is from \cite[Section 3.3.2]{Prashanth-thesis}.

\begin{tabular}{r l}
{\tt Get (A|Ch)} & channel type  takes a sequential type {\tt A} and a channel of type {\tt Ch}. \\
{\tt Put (A|Ch)} & channel type takes a sequential type {\tt A} and a channel of type {\tt Ch}. \\ 
{\tt Neg (Ch)} & channel type takes a channel of type {\tt P}. \\ 
{\tt TopBot} & which is acronym for {\tt Top} and {\tt Bottom} does not take arguments. \\
{\tt Ch1 (+) Ch2} & takes in two channels of types {\tt Ch1} and {\tt Ch2} \\
{\tt Ch1 (*) Ch2} & takes in two channels of types {\tt Ch1} and {\tt Ch2}

\end{tabular}

The polarity of a channel determines the operations that a process may perform on these types, see Section \ref{sec:concurrent-operators}.

\subsection*{Constructing custom channel types}

In CaMPL, a programmer may built channels of custom types from the built-in types using {\tt protocol} keyword. Protocols are concurrent analogue of dataypes from the sequential world, and channels are concurrent analogue of instances of datatypes.

Let us consider the following example of a protocol (from Example ??):

\begin{center}
\begin{varwidth}{\linewidth}
\begin{verbatim}
protocol Echo => S =
    EchoSend :: Put( [Char] | Get( [Char] | S)) => S
    EchoClose :: TopBot => S
\end{verbatim}
\end{varwidth}
\end{center}

In the above code, {\tt Echo} is a type constructor that takes in an right conncurrent type {\tt S}. {\tt EchoSend} and {\tt EchoClose} are called {\bf protocol handles}. A channel of type Echo is {\em activated} when a process puts a handle on the on it using {\sf hput} (See Section \ref{subsec:pairs}). Once a channel activated, the channel may be used for communication by the processes it is connected to according to the rules of the handle. For example, {\tt EchoSend} enables sending and receiving over {\tt S} using {\tt Put} and {\tt Get} (see Section \ref{subsec:put-get}), and {\tt EchoClose} takes in {\tt S} and converts it into {\tt TopBot} type (thereby disallowing any further communication).

Let us consider the following example of a protocols (from Example ??):

\begin{center}
\begin{varwidth}{\linewidth}
\begin{verbatim}
protocol Passer( | M ) => S =
    Passer :: M (+) (Neg(M) (*) S)  => S
\end{verbatim}
\end{varwidth}
\end{center}

In the above code, {\tt Passer} is a type constructor takes in a left concurrent type {\tt M} and a right concurrent type {\tt S}. The handle {\tt Passer} takes in a {\tt S} type and produces a compound type {\tt M (+) (Neg(M) (*) S)}.

\begin{center}
\begin{varwidth}{\linewidth}
\begin{verbatim}
protocol MemCell (A | ) => S =
    MemPut :: Put(A|S) => S
    MemGet :: Get(A|S) => S
    MemCls :: TopBot => S
\end{verbatim}
\end{varwidth}
\end{center}

In the above code, {\tt MemCell} is a type constructor takes in an input sequential type {\tt A} and a right concurrent type {\tt S}. The handle {\tt MemPut} and {\tt MemGet} takes in a {\tt S} type and enables send-receive of type {\tt A} over {\tt S}. The handle {\tt MemCls} takes in a {\tt S} type and produces a {\tt TopBot} which ends all communication.

Dual to protocols, CaMPL supports {\tt coprotocol}s signifying the inherent duality in direction of information flow between two processes --- from left to right, or from right to left. For example, consider the following protocol and coprotocols.

\begin{center}
\begin{varwidth}{\linewidth}
\begin{verbatim}
protocol EchoSimple => S =
    EchoSend :: Put( [Char] | S)) => S
    
coprotocol coEchoSimple => S =
    coEchoSend ::  S  => Put( [Char] | S))
\end{verbatim}
\end{varwidth}
\end{center}

Suppose {\tt ch} is a channel with the handle {\tt EchoSend}, the message is sent from right polarity to left polarity, as shown in (1) and (2) in the following figure. One can use a coprotocol to avoid bending wires as shown in (3).
\[ \includegraphics[scale=0.12]{figs/coprotocol.jpeg} \]
A coprotocol is an added functionality rather than being a unique feature. All our examples use {\tt protocol} keyword to construct custom types.


\section{Concurrent operators}
\label{sec:concurrent-operators}

Table \ref{tab:mpl-constructs} summarizes the operations on the concurrent types.

 \begin{table}[!h]
\centering
	\begin{tabular}{|l|l|l|}
	\hline
	\textsf{id} & equates two channels &  non-blocking  \\ \hline
	\textsf{neg} & negates a channel & non-blocking \\ \hline
	\textsf{plug} & connects two processes by a channel & non-blocking \\ \hline
	\textsf{Get} & send/receive a value on a channel & depends on the polarity \\ \hline
	\textsf{Put} & send/receive a value on a channel &  depends on the polarity \\ \hline
	\textsf{hput} & puts a handle on a channel & non-blocking \\ \hline
	\textsf{hcase} & cases on the handles obtained on channel & blocking \\ \hline
	\textsf{split} & splits a channel into two channels  & blocking\\ \hline
	\textsf{fork} & forks two new processes & non-blocking \\ \hline
	\textsf{close} & closes a channel & non-blocking \\ \hline
	\textsf{halt} & closes a channel. Usually the last channel is halted. & non-blocking \\ \hline
	\end{tabular}
\caption{Concurrent MPL Constructs}
\label{tab:mpl-constructs}
\end{table} 

\subsection{Sending and receiving messsages using {\tt Put} and {\tt Get}}
\label{subsec:put-get}

The semantics of message passing in CaMPL is given by a linear actegory. The operator $\circ$ in linear actegory corresponds to the {\sf Put} and the operator $\bullet$ corresponds to the {\sf Get} in CaMPL.

\begin{figure}
\[  
 [{\tt Put}]: \quad \xymatrix{   
 \blackman  \quad
 \ar[rr]^{(r) \quad A \circ X \quad (l)}  
 &  & \quad \blackman   } \quad \quad \quad 
 [{\tt Get}]: \quad\xymatrix{  
 \blackman  \quad
 \ar@{<-}[rr]^{(r) \quad B \bullet X \quad (l)} 
 &  & \quad \blackman   }  
 \]
 \caption{Schematic of {\tt Put} and {\tt Get}}
 \label{Fig: Put and Get}
\end{figure}

Given a channel of type $A \circ X$ or \texttt{Put(A | X)}, if it is of:
\begin{itemize}
	\item right polarity, then the process may 'send' a message of type {\tt A},
	\item left polarity, then the process may 'receive' a message of {\tt A} over the channel.
\end{itemize}

Dually, given a channel of type $B \bullet X$ or \texttt{Get(B | X)}, if it is:
\begin{itemize}
	\item left polarity, then the process may 'send' a message of type {\tt A},
	\item right polarity, then the process may 'receive' a message of {\tt A} over the channel.
\end{itemize}

Thus, with channels of {\tt Put} type, messages are sent towards the right using right polarity, and  
 with channels of {\tt Get} type, messages are sent towards the left using left polarity, see Figure \ref{Fig: Put and Get}. Figure \ref{Fig: Put and Get syntax} shows the syntax for {\tt Put} and {\tt Get}. Figure \ref{Fig: sequent rules for Put} shows the sequent rules for \texttt{Put}. 

\begin{figure}[h]
\begin{center}
	\begin{varwidth}{\linewidth}
		\begin{verbatim}
			Put( <sequential_type> | <concurrent_type> )
		\end{verbatim}
	\end{varwidth}

	\begin{varwidth}{\linewidth}
		\begin{verbatim}
			Get( <sequential_type> | <concurrent_type> )
		\end{verbatim}
	\end{varwidth}
\end{center}
\vspace{-2em}
\caption{Syntax for {\tt Put} and {\tt Get}}
\label{Fig: Put and Get syntax}
\end{figure}

% Side-by-side figures
\begin{figure}[h]
\begin{minipage}{.5\textwidth}
	\[ \infer[\circ_R]{B ~|~ X \dashvv A' \circ Y}{A \dashv A' \quad A, B ~|~ X \dashvv Y} \]
	\[ \infer[\circ_L]{A ~|~ B \circ X \dashvv Y}{A,B ~|~ X \dashvv Y} \]
  	\vspace{-2em}
  \captionof{figure}{Sequent rules for Put}
  \label{Fig: sequent rules for Put}
\end{minipage}%
\begin{minipage}{.5\textwidth}
	\[ \infer[\bullet_R]{B ~|~ X \dashvv A \circ Y}{A,B ~|~ X \dashvv Y} \]
	\[ \infer[\bullet_L]{A ~|~ B' \bullet X \dashvv Y}{B \dashv B' \quad \quad A,B ~|~ X \dashvv Y} \]
	\vspace{-2em}
  \captionof{figure}{Sequent rules for Get}
  \label{Fig: sequent rules for Get}
\end{minipage}
\end{figure}

Figure \ref{Fig: Put process} shows a sample communication via the \texttt{Put} type. Process \texttt{p} has a right polarity channel {\tt y} while process \texttt{q} has a left polarity channel \texttt{y}, both of type \texttt{Put([Char]|X)}. 
Process \texttt{p} sends the string ``Hello" using \texttt{send} on its channel \texttt{y} which is received by process \texttt{q} on its channel {\tt y} using \texttt{recv}. 
Dually, in Figure \ref{Fig: Get process}, Process \texttt{p} has a left polarity channel {\tt y} while process \texttt{q} has a right polarity channel \texttt{y}, each of type \texttt{Get([Char]|X)}. 
Process \texttt{p} sends a string {\tt "Hello"} on \texttt{y} using \texttt{send} call and process \texttt{q} receives it on {\tt y} using the \texttt{recv} call. 

% Side-by-side figures
\begin{figure}[h]
\centering
\begin{minipage}{.5\textwidth}
	\begin{verbatim}
		proc p :: A | => Put( [Char] | Y ) = 
			a | => y -> do
				send "Hello" on y
				halt y
			
		proc q ::  | Put( [Char] | Y ) =>  = 
			| y => do
				recv b on y
				halt y

	\end{verbatim}
  	\vspace{-3em}
  \captionof{figure}{Send-Receive via \texttt{Put}}
  \label{Fig: Put process}
\end{minipage}%
\begin{minipage}{.5\textwidth}
  \centering
	\begin{verbatim}
		proc p :: A | Get( [Char] | Y ) => = 
			a | y => -> do
				send "Hello" on y
				halt y
			
		proc q ::  | => Get( [Char] | Y )  = 
			| => y do
				recv b on y
				halt y

	\end{verbatim}
	\vspace{-3em}
  \captionof{figure}{Send-Receive via \texttt{Get}}
  \label{Fig: Get process}
\end{minipage}
\end{figure}

The above described usage of \texttt{Put} and \texttt{Get} channel types apply for channels which are instances of Protocols. For coProtocols, the role of {\tt Put} and {\tt Get} gets reversed, as shown in the following tables:
\begin{center}
	\begin{tabular}{ c || c | c }
		     (P)       & (r) & (l) \\
		 \hline
		 \hline      
		 {\tt Get}  & {\tt recv}  & {\tt send} \\
		 \hline
		 {\tt Put}  & {\tt send}  & {\tt recv} 
	\end{tabular}
	\quad \quad 
	\begin{tabular}{ c || c | c }
		     (coP)       & (r) & (l) \\
		 \hline
		 \hline      
		 {\tt Get}  & {\tt send}  & {\tt recv} \\
		 \hline
		 {\tt Put}  & {\tt recv}  & {\tt send} 
	\end{tabular}
\end{center}

\subsection{Connecting channels using {\sf plug}}

Composition of two processes in the concurrent side of CaMPL is defined by 
{\em plug} command (which is the {\em cut} rule in linear logic. 
When two processes that are running in parallel are plugged to each other 
along a channel, they can communicate and pass
messages through that channel in both directions. Two processes can only be plugged to
each other along a channel, if they both have a channel of the same type but opposite
polarity. One channel can be used to connect exactly two processes. 

The following program plugs process \texttt{p} with process \texttt{q} via channel \texttt{y}. For Process \texttt{p}, channel \texttt{y} has right polarity while for process \texttt{q} the same channel has left polarity.

\begin{center}
\begin{varwidth}{\linewidth}
\begin{verbatim}
	proc r :: A, B | X => Z = 
		a, b | x => z -> 
			plug 
				p(a | x => y)
				q(b | y => z)
\end{verbatim}
\end{varwidth}
\end{center}

The sequent calculus version of the above program is as follows:
\[ \infer[cut]{A, B ~|~ X \dashvv Z}{A ~|~ X \dashvv Y \quad \quad B ~|~ Y \dashvv Z } \]


\subsection{Duplicating channels using {\tt id} and {\tt neg}}

\subsection{Ending communication using {\tt halt} and {\tt close}}

\subsection{Paired constructs: {\sf fork}~/~{\sf split} and  {\sf hput}~/~{\sf hcase} }
\label{subsec:pairs}

\subsection*{Multichannel communication using {\sf Split} and {\sf Fork}}

\begin{figure}[h]
\begin{center}
	\begin{varwidth}{\linewidth}
		\begin{verbatim}
			fork <bundled_channel> as 
				<new_ch1> [with <channels>] -> <process1>
				<new_ch2> [with <channels>] -> <process2>
		\end{verbatim}
	\end{varwidth}

	\begin{varwidth}{\linewidth}
		\begin{verbatim}
			split <bundled_ch> into <new_ch1>, <new_ch2>
		\end{verbatim}
	\end{varwidth}
\end{center}
\vspace{-2em}
\caption{Syntax for fork and split}
\label{Fig: fork and split}
\end{figure}

The underlying mathematics of CaMPL allows plugging two processes along utmost one channel to avoid cycles. However, if one wishes to plug processes along more than one channel, one may do so safely (with no deadlocking) using {\sf split} and {\sf fork}. The tensor $(*)$ and the par $(+)$ functors (operators) bundles two or more channels together, and produces a new channel for communication (in linear actegories, $(*)$ and $(+)$ are written as $\otimes$ and $\oplus$ respectively).

If a process has a right polarity channel of type $A (*) B$, then it can {\sf fork} into two processes with two distinct channels $A$ and $B$ of right polarity. Dually, if a process is has a left polarity channel of type $A (+) B$, then it can {\sf fork} into two processes with two distinct channels $A$ and $B$ of left polarity. {\sf fork} is a non-blocking call. Accordingly, sequent rules for for fork are shown in Figure \ref{Fig: sequent rules fork}:
\begin{figure}[h]
	\[ \infer[\otimes_R]{A, B ~|~ X1, X2 \dashvv Y1 \otimes Y2}{A ~|~ X1 \dashvv Y1 \quad \quad B ~|~ X2 \dashvv Y2}  \quad \quad \quad \quad \quad \quad \infer[\oplus_L]{A,B ~|~ X1 \oplus X2 \dashvv Y1, Y2}{A ~|~ X1 \dashvv Y1 \quad \quad B ~|~ X2 \dashvv Y2} \]
\vspace{-2em}
\caption{Sequent rules for {\tt fork}}
\label{Fig: sequent rules fork}
\end{figure}

Figures \ref{Fig: fork1} show a process {\sf p} with a right polarity channel of type $Y1 (*) Y2$. Using the compound channel, the process forks into a process {\sf p} and a process {\sf q}. Similarly, Figure \ref{Fig: fork2} is an example of process forking.

% Side-by-side figures
\begin{figure}[h]
\centering
\begin{minipage}{.5\textwidth}
	\begin{verbatim}
		proc p :: A, B | X1, X2 => Y1 (*) Y2 = 
			a, b | x1, x2 => y -> 
				fork y as 
					y1 -> p(a | x1 => y1)
					y2 -> q(b | x2 => y2)
	\end{verbatim}
  	\vspace{-2em}
  \captionof{figure}{Process forking using {\tt (*)}}
  \label{Fig: fork1}
\end{minipage}%
\begin{minipage}{.5\textwidth}
  \centering
	\begin{verbatim}
		proc p :: A, B | X1 (+) X2 => Y1 ,Y2 = 
			a, b | x => y1, y2 -> 
				fork x as 
					x1 -> p(a | x1 => y1)
					x2 -> q(b | x2 => y2)
	\end{verbatim}  
	\vspace{-2em}
  \captionof{figure}{Process forking using {\tt (+)}}
  \label{Fig: fork2}
\end{minipage}
\end{figure}

If a process is connected to a left polarity channel of type {\tt A (*) B}, then it can {\sf split} the bundle into two distinct channels {\tt A} and {\tt B} of left polarity to be used by the process for further computations. Dually, if a process is connected to a right polarity channel of type {\tt A (+) B}, then it can {\sf split} the bundle into two two distinct channels {\tt A} and {\tt B} of right polarity. {\sf split} is a blocking call --- that is a process calling split will be blocked unless a {\sf fork} occurs at the other end of the same channel.

The sequent rules for {\sf split call} are shown in Figure \ref{Fig: sequent rules for split}.

\begin{figure}[h]
	\[ \infer[\otimes_R]{A ~|~ X1 \dashvv Y1 \oplus Y2}{A ~|~ X1 \dashvv Y1, Y2} \quad \quad \quad \quad \quad \quad \infer[\oplus_L]{A ~|~ X1, X2 \dashvv Y1}{A ~|~ X1 \otimes X2 \dashvv Y1} \]
\vspace{-2em}
\caption{Sequent rules for {\tt split}}
\label{Fig: sequent rules for split}
\end{figure}

Figure \ref{Fig: split1} shows a process {\sf q} splitting an left polarity and calling a process $p$. Dually, Figure \ref{Fig: split2} shows a process splitting on the right polarity.

% Side-by-side figures
\begin{figure}[h]
\centering
\begin{minipage}{.5\textwidth}
	\begin{verbatim}
		proc p :: A | X => Y1, Y2 = 
			a | x => y1, y2 -> ... 
			
		proc q :: A | X => Y1 (+) Y2 = 
			a, b | x => y -> do
					split y into y1, y2
					p( a | x => y1,y2)
	\end{verbatim}
  	\vspace{-2em}
  \captionof{figure}{Process splitting at the right polarity}
  \label{Fig: split1}
\end{minipage}%
\begin{minipage}{.5\textwidth}
  \centering
	\begin{verbatim}
		proc p :: A | X => Y1, Y2 = 
			a | x => y1, y2 -> ... 
		
		proc q :: A | X1 (*) X2 => Y = 
			a, b | x => y -> do
					split x into x1, x2
					p( a | x1,x2 => y)
	\end{verbatim}
	\vspace{-2em}
  \captionof{figure}{Process splitting at the left polarity}
  \label{Fig: split2}
\end{minipage}
\end{figure}

\subsection*{Communicating handles using {\tt hcase} and {\tt hput}}

The {\tt hput} command sends a handle of a protocol over a right polarity channel which is matched by a {\tt hcase} command on the left polarity. For co-protocols, handles are sent over a left polarity channel and received over the corresponding right polarity channel. Figure \ref{Fig: hput and hcase} shows the syntax for {\tt hput} and {\tt hcase}.

\begin{figure}[h]
\begin{center}
	\begin{varwidth}{\linewidth}
		\begin{verbatim}
			hput <handle_name> on <channel_name>	
		\end{verbatim}
	\end{varwidth}

	\begin{varwidth}{\linewidth}
		\begin{verbatim}
			hcase <channel_name> of
				<handle1> -> ... 
				<handle2> -> ... 
				.
				.
				<handlen> -> ... 
		\end{verbatim}
	\end{varwidth}
\end{center}
\vspace{-2em}
\caption{Syntax for {\tt hput} and {\tt hcase}}
\label{Fig: hput and hcase}
\end{figure}

For example, in line ?? of the program shown in Section \ref{}, the {\tt Client}  hputs {\tt EchoClose} on channel {\tt ch} of type {\tt Echo}. This {\tt hput} is matched by {\tt hcase} in line ?? of the {\tt Server}. 

\subsection{Non-deterministic communication using {\tt race}}

\subsection{Higher-order message passing using {\tt store} and {\tt use}}
	
\section{Example programs}

\subsection{EchoServer}

\subsection*{Expected program behavior} There are two processes {\em a client} and {\em a server} communicating with one another. The server is connected to the environment via a console, and the client via a \texttt{StringTerminal}. The server reads a string from the terminal, relays it to the server who prints it on the console, and sends the string back to the client. When the user provides an empty string, the processes terminate. 

The topology of the processes and their connection remains the same throughout the program. The topology is shown in the diagram below:
<DIAGRAM>


\subsection*{CaMPL program}
The main protocol used in this program is \texttt{Echo}. It provides a handle \texttt{EchoSend} of Put-Get type which will be used to send-receive or receive-send a message depending on the polarity of channel ends. The handle \texttt{EchoClosed} is used to close a channel of \texttt{Echo} type. 

\begin{verbatim}
protocol Echo => S =
    EchoSend :: Put( [Char] | Get( [Char] | S)) => S
    EchoClose :: TopBot => S
\end{verbatim}

The client process is connected to a channel of \texttt{Echo} type at the output end. It first reads a string (provided by the user) from the terminal. If the user provided a non-empty string, it will place \texttt{EchoSend} handle on the channel followed by a \texttt{put} to send the string. Then, it performs a (blocking) \texttt{get} to receive data from server and loops. If the use provided an empty string, it signals the server by placing the \texttt{EchoClose} handle on the channel. It closes its connection and terminates.

\begin{verbatim}

proc client :: | => Echo, ClientConsole =
    | => ch, console -> do
        hput StringTerminalGet on console
        get fruit on console

        case fruit of
            [] -> do
                hput EchoClose on ch
                hput StringTerminalClose on console
                close console
                halt ch

            _:_ -> do
                hput EchoSend on ch
                -- send data
                put fruit on ch 
                -- receive echoed data
                get echoed on ch  
                -- print received data
                hput StringTerminalPut on console
                put ('>':' ':echoed) on console

                -- loop
                client( | => ch, console)
\end{verbatim}    

The server process is connected to a channel of \texttt{Echo} type at the input end. It first performs a (blocking) \texttt{hcase}. If the handle received is \texttt{EchoSend}, then it receives data (sent by the client) using a {blocking} \texttt{get}. It sends the received data back as an acknowledgement using a \texttt{put} (since the handle \texttt{EchoSend} does Put-Get), and loops. If the handle received is \texttt{EchoClose} then it closes it connection with the channel and terminates. 

\begin{verbatim}
proc server :: | Echo, LogConsole => =
    | ch, console => -> do
        hcase ch of
            EchoSend -> do
                -- receive data
                get fruit on ch

                -- print data
                hput ConsolePut on console
                put fruit on console

                -- echo (send) data 
                put fruit on ch
                server( | ch, console => )
            EchoClose -> do
                hput ConsolePut on console
                put "Done" on console
                hput ConsoleClose on console
                close console
                halt ch
\end{verbatim}

The following is the code for ClientConsole and the server's LogConsole for reading input and printing output. 

\begin{verbatim}

protocol ClientConsole => S =
    StringTerminalGet :: Get( [Char] | S) => S
    StringTerminalPut :: Put( [Char] | S) => S
    StringTerminalClose :: TopBot => S

coprotocol S => LogConsole =
    ConsolePut :: S => Get( [Char] | S)
    ConsoleClose :: S => TopBot
\end{verbatim}

The following process  is the first process to be invoked by the program which initiates the topology, and runs the client and the server. 

\begin{verbatim}
proc run :: | LogConsole => ClientConsole =
    | console_s => console_c -> plug
        client( | => ch, console_c )
        server( | ch, console_s => )

\end{verbatim}

The following items were suggested by Hashimoto as improvements to CaMPL syntax:

\begin{itemize}
	\item While we have \texttt{Get} and \texttt{Put} for protocols (which means get and put on the output polarity), it will be user-friendly \texttt{coGet} and \texttt{coPut} for coprotocols (to mean \texttt{put} and \texttt{get} respectively on the output terminal.
	\item Racing on handles instead of \texttt{put}. So be able to race on \texttt{hput}, and \texttt{fork} handles.
	\item Merge the \texttt{hput} followed by the get or put. 
	\item \texttt{on <channel> hput <handle>} instead of \texttt{hput <handle> on <channel>}. 
	\item Currently, to halt a process, the channels are first closed and the final \texttt{halt <channel>} command takes in the name of the last channel to be closed. Instead, close all the channels followed by \texttt{halt} command.
\end{itemize}

\subsection{Mutual Exclusion}


\subsection{Non-deterministic communication}

\section{Notes on the compiler and interface design}

CaMPL has concurrent and sequential types. Some useful tables and notes.

The following table summarizes the analogues of sequential and concurrent worlds.

\begin{center}
\begin{tabular}{ c | c | c | c }
 {\bf Sequential} & Datatypes  & Functions & Instances \\ 
   & (and coDatatypes)  &  &  \\
 \hline
 {\bf Concurrent} & Protocols & Processes & Channels \\  
 & (and coProtocols)  &  &  \\
\end{tabular}
\end{center}

Channels are instances of (co)protocols. Given a process and a channel {\em connected} to it, the channel may have input (+) or output polarity (-) for that process. 

Here are a few practical programming notes:
\begin{itemize}
	\item {\tt close} command closes a channel. {\tt halt} command is used on a process which has only one connected channel. Halt closes the channel and halts the process. 
	
	{\bf Design question:} Why not interpret closing all the channels as a signal to halt? For example: 
	\begin{verbatim}
		 close ch1  
		 close ch2  
		 halt
	\end{verbatim}
	
	\item The handles \tt{ConsoleGet}, \tt{ConsolePut}, \tt{ConsoleClose}, \tt{StringTerminalGet}, \tt{StringTerminalPut}, and \tt{StringTerminalClose} which are used for reading from and writing to terminals are hard-coded.  
	
\begin{center}
	\begin{tabular}{ c | c | c }
		     (P)       & (+) & (-) \\
		 \hline      
		 {\tt Get}  & {\tt get}  & {\tt put} \\
		 \hline
		 {\tt Put}  & {\tt put}  & {\tt get} 
	\end{tabular}
	\quad \quad 
	\begin{tabular}{ c | c | c }
		     (coP)       & (+) & (-) \\
		 \hline      
		 {\tt Get}  & {\tt put}  & {\tt get} \\
		 \hline
		 {\tt Put}  & {\tt get}  & {\tt put} 
	\end{tabular}
	\quad \quad 
	\begin{tabular}{ c | c | c }
		            & (+) & (-) \\
		 \hline      
		 (P)  & {\tt hput}  & {\tt hcase} \\
		 \hline
		 (coP)  & {\tt hcase}  & {\tt hput} 
	\end{tabular}
\end{center}
 
\end{itemize}

\section{Mathematical Underpinning}

\subsection{Category Theory}

The mathematical semantics of CaMPL is modeled by a {\em linear actegory} \cite{CoP07}:4.2 where a symmetric monoidal categorical category $\X$ --- representing the semantics of of the sequential side --- acts on a symmetric linearly distributive category $\C$ --- representing the semantics of the concurrent side. This interaction is defined by two action functors:

\[ \circ: \A \times \C \to \C \quad \quad \text{ and } \quad \quad \bullet: \A^{\sf op} \times \C \to \C \]

These functors describe how sequential data, or {\em messages}, are transmitted through {\em channels}, which are modeled as concurrent types. The $\circ$ functor is the left parametrized left adjoint of $\bullet$ in the sense that the following is a parametrized adjunction:

\[ A \in \A,  \quad X \circ - \dashv A \bullet - : \C \to \C \]

The adjunction signifies that a process transmitting or receiving a message can do so from either end of a channel. 

\subsection{Message Passing Logic}

The message passing logic, {\bf Msg}, gives a type system for concurrent proccesses which use message passing as their concurrency primitive \cite{CoP07}. The logic they introduced is two-tiered with rules governing the interaction of the two tiers. The two-tiers include the logic of messages and logic of message-passing.

\subsubsection{The logic of messages}

This tier concerned with generation of messages represents the logic of computation, and corresponds to the type system for sequential computation. The proofs in this logic correspond to sequential programs. The logic is presented in a Gentzen sequent style: a sequent takes the form
\[ \Phi \vdash A \]
where the {\em antecedent} (which we will also call the {\em context}) of $\Phi$ is a comma-separated list of formulas and the {\em succedent} $A$ is a single formula. The term calculus for this logic is given in Figure \ref{Fig:MsgRules}. In the inference rules, {\em subs} stands for substitution and is the cut rule. 

\begin{figure}
\centering
	\includegraphics[scale=0.5]{figs/MsgRules.PNG}
	\caption{Inference rules for {\bf Msg}}
	\label{Fig:MsgRules}
\end{figure}

\subsubsection{The logic of message-passing}
	
	The logic of message, {\bf PMsg}, passing concerned with communication over channels represents the logic of communication, and is concerned with channels over which processes communicate messages. A sequent of {\bf PMsg} has three components all of which are unordered lists: list $\Phi$ of message types, list $\Lambda$ of left polarity channels, and list $\Delta$ of right polarity channels which, together define a sequent of PMsg: 
\[ \Phi ~|~ \Lambda \vvdash \Delta \]	
The inference rules for {\bf PMsg} are presented in Figure \ref{Fig:PMsgRules}. Most of the rules of this calculus are standard ones for two-sided multiplicative linear logic except the {\em action} rules $\circ_l$, $\circ_r$, $\bullet_l$, and $\bullet_r$ which allow messages to be bound to channels of interaction.
\begin{figure}
\centering
	\includegraphics[scale=0.6]{figs/PMsgRules.PNG}
	\caption{Inference rules for {\bf PMsg}}
	\label{Fig:PMsgRules}
\end{figure}
	
Thus, the message passing logic provides a clean separation of computation and communication layers thereby allowing the complexities associated with each layer to be addressed effectively. Figure \ref{Fig:programming-syntax} provides the programming syntax for CaMPL.
\begin{figure}
\centering
	\includegraphics[scale=0.6]{figs/programming-syntax.png}
	\caption{Programming syntax for {\bf PMsg}}
	\label{Fig:programming-syntax}
\end{figure}





\end{document}
