\documentclass[11pt]{article}
\input{preamble}
\input{macros}
\addbibresource{refs.bib}
\linespread{1.11}

\title{Categorical Message Passing Language (CaMPL)}
\author{
    Robin Cockett\thanks{University of Calgary} \and Daniel Hashimoto\thanks{Universidade Federal do Rio de Janeiro} \and Melika Norouzbeygi* \and Priyaa Varshinee Srinivasan\thanks{Tallinn University of Technology}}
%\def\authorrunning{D.\ I.\ Spivak \& P.\ V.\ Srinivasan}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
This document is a simple introduction to  a novel concurrent programming language called the 
categorical message passing language built on the mathematics of linear actegories. 
Categorical Message Passing Language, to the best of our knowledge, 
the only\footnote{Is this true?} concurrent programming language with mathematical underpinnings. 
It is a functional-style programming language with the abstract machine built on Haskell. 
The current version of CaMPL compiler is to be considered a proto-alpha, a proof-of-concept 
of a programming language built from the mathematics of linear actegories.
\end{abstract}

%\addcontentsline{toc}{section}{References}

\tableofcontents

\section{Introduction}

Explain current state of concurrency and why CaMPL is novel (Curry-Howard-Lambek-like correspondence), and its history.

\section{Sequential types}

\section{Concurrent types}


At any instance in run-time, the topology of a CaMPL program, consists of a finite set of {\em processes} connected by {\em channels} arranged as an acyclic graph with processes as nodes and channels as edges of the graph. The semantics of the concurrent side of CaMPL is given by a linearly distributive category whose objects are interpreted as concurrent channel types and maps as processes between channels. The following table draws analogue between the constructs of sequential and concurrent MPL.

\begin{center}
\begin{tabular}{ | c ||  c | c | c | }
 \hline
 {\bf Sequential} & Functions & Datatypes   & Instances \\ 
   & & (and coDatatypes)   &  \\
 \hline
 {\bf Concurrent} & Processes & Protocols  & Channels \\  
 & & (and coProtocols)    &  \\
 \hline
\end{tabular}
\end{center} 


\subsection{Processes}

In CaMPL, a process consists of an optional list of: 
\begin{itemize}
	\item sequential input types,
	\item left polarity or input channels, and
	\item right polarity or output channels.
\end{itemize}

For example, the following code shows a process \texttt{p} with a sequential input of type $A$, a left polarity channel of type $X$, and a right polarity channel of type $Y$ as defined in CAMPL. 

  \begin{center}
  \begin{varwidth}{\linewidth}
  \begin{verbatim}
  	proc p :: A | X => Y =
					a | x => y -> ...
  \end{verbatim}
  \end{varwidth}
  \end{center}
  
  \vspace{-1em}
  
  Note that \texttt{p} is connected to the right end of \texttt{x} and to the left end of {\tt y}.
  
  \[ \xymatrix{  
  \ar@{-}[r]^{X\quad \quad}  & ~~ \blackman  ~~ \ar@{-}[r]^{\quad \quad Y} &    } \]
  
Process {\tt p} can be equivalently expressed in the sequent calculus as:
$  A ~|~ X ~\dashvv~ Y $.  



\subsection{Channels}

In CaMPL, processes communicate (send and receive messages) via channels. CaMPL comes with built-in channel types from which one may build custom channel types. For any process {\tt p}, the behavior of the channels depends on the polarity.The polarity of a channel determines the kind of operations that my be performed on the channel, see Section \ref{sec:concurrent-operators}.

\subsubsection{Built-in Channel types}

The following information is from \cite[Section 3.3.2]{Prashanth-thesis}.

\begin{tabular}{r l}
{\tt Get (A|Ch)} & channel type  takes a sequential type {\tt A} and a channel of type {\tt Ch}. \\
{\tt Put (A|Ch)} & channel type takes a sequential type {\tt A} and a channel of type {\tt Ch}. \\ 
{\tt Neg (Ch)} & channel type takes a channel of type {\tt P}. \\ 
{\tt TopBot} & which is acronym for {\tt Top} and {\tt Bottom} does not take arguments. \\
{\tt Ch1 (+) Ch2} & takes in two channels of types {\tt Ch1} and {\tt Ch2} \\
{\tt Ch1 (*) Ch2} & takes in two channels of types {\tt Ch1} and {\tt Ch2}

\end{tabular}



\subsubsection{Constructing custom channel types}

In CaMPL, a programmer may built channels of custom types from the built-in types using {\tt protocol} keyword. Protocols are concurrent analogue of dataypes from the sequential world, and channels are concurrent analogue of instances of datatypes.

Let us consider the following example of a protocol (from Example ??):

\begin{center}
\begin{varwidth}{\linewidth}
\begin{verbatim}
protocol Echo => S =
    EchoSend :: Put( [Char] | Get( [Char] | S)) => S
    EchoClose :: TopBot => S
\end{verbatim}
\end{varwidth}
\end{center}

In the above code, {\tt Echo} is a type constructor that takes in an right conncurrent type {\tt S}. {\tt EchoSend} and {\tt EchoClose} are called {\bf protocol handles}. A channel of type Echo is {\em activated} when a process puts a handle on the on it using {\sf hput} (See Section \ref{subsec:pairs}). Once a channel activated, the channel may be used for communication by the processes it is connected to according to the rules of the handle. For example, {\tt EchoSend} enables sending and receiving over {\tt S} using {\tt Put} and {\tt Get} (see Section \ref{subsec:put-get}), and {\tt EchoClose} takes in {\tt S} and converts it into {\tt TopBot} type (thereby disallowing any further communication).

Let us consider the following example of a protocols (from Example ??):

\begin{center}
\begin{varwidth}{\linewidth}
\begin{verbatim}
protocol Passer( | M ) => S =
    Passer :: M (+) (Neg(M) (*) S)  => S
\end{verbatim}
\end{varwidth}
\end{center}

In the above code, {\tt Passer} is a type constructor takes in a left concurrent type {\tt M} and a right concurrent type {\tt S}. The handle {\tt Passer} takes in a {\tt S} type and produces a compound type {\tt M (+) (Neg(M) (*) S)}.

\begin{center}
\begin{varwidth}{\linewidth}
\begin{verbatim}
protocol MemCell (A | ) => S =
    MemPut :: Put(A|S) => S
    MemGet :: Get(A|S) => S
    MemCls :: TopBot => S
\end{verbatim}
\end{varwidth}
\end{center}

In the above code, {\tt MemCell} is a type constructor takes in an input sequential type {\tt A} and a right concurrent type {\tt S}. The handle {\tt MemPut} and {\tt MemGet} takes in a {\tt S} type and enables send-receive of type {\tt A} over {\tt S}. The handle {\tt MemCls} takes in a {\tt S} type and produces a {\tt TopBot} which ends all communication.

Dual to protocols, CaMPL supports {\tt coprotocol}s signifying the inherent duality in direction of information flow between two processes --- from left to right, or from right to left. For example, consider the following protocol and coprotocols.

\begin{center}
\begin{varwidth}{\linewidth}
\begin{verbatim}
protocol EchoSimple => S =
    EchoSend :: Put( [Char] | S)) => S
    
coprotocol coEchoSimple => S =
    coEchoSend ::  S  => Put( [Char] | S))
\end{verbatim}
\end{varwidth}
\end{center}

Suppose {\tt ch} is a channel with the handle {\tt EchoSend}, the message is sent from right polarity to left polarity, as shown in (1) and (2) in the following figure. One can use a coprotocol to avoid bending wires as shown in (3).
\[ \includegraphics[scale=0.12]{figs/coprotocol.jpeg} \]
A coprotocol is an added functionality rather than being a unique feature. All our examples use {\tt protocol} keyword to construct custom types.


\section{Concurrent operators}
\label{sec:concurrent-operators}

Table \ref{tab:mpl-constructs} summarizes the operations on the concurrent types.

 \begin{table}[!h]
\centering
	\begin{tabular}{|l|l|l|}
	\hline
	\textsf{id} & equates two channels &  non-blocking  \\ \hline
	\textsf{neg} & negates a channel & non-blocking \\ \hline
	\textsf{plug} & connects two processes by a channel & non-blocking \\ \hline
	\textsf{get} & send/receive a value on a channel & depends on the polarity \\ \hline
	\textsf{put} & send/receive a value on a channel &  depends on the polarity \\ \hline
	\textsf{hput} & puts a handle on a channel & non-blocking \\ \hline
	\textsf{hcase} & cases on the handles obtained on channel & blocking \\ \hline
	\textsf{split} & splits a channel into two channels  & blocking\\ \hline
	\textsf{fork} & forks two new processes & non-blocking \\ \hline
	\textsf{close} & closes a channel & non-blocking \\ \hline
	\textsf{halt} & closes a channel. Usually the last channel is halted. & non-blocking \\ \hline
	\end{tabular}
\caption{Concurrent MPL Constructs}
\label{tab:mpl-constructs}
\end{table} 

\subsection{Connecting channels using {\tt plug}}

\begin{center}
\begin{varwidth}{\linewidth}
\begin{verbatim}
	plug 
		    p1( | ch1 => ch2)
		    p2( | ch2 => ch3)
		    p3( | ch3 => ch4)
		    ...
		    pn( | chn => last_ch)
\end{verbatim}
\end{varwidth}
\end{center}

Composition of two or more processes in the concurrent side of CaMPL is defined by 
{\em plug} command (which is the {\em cut} rule in linear logic. Two processes can only be plugged to each other along a channel, if they share a channel of the same type but opposite
polarity.

The following program plugs process \texttt{p} with process \texttt{q} via channel \texttt{y}. Note that, channel \texttt{y} has right polarity for process \texttt{p} while  it has left polarity for process \texttt{q}. Moreover, process {\tt r} duplicated the sequential type using {\tt a} twice, however it uses all concurrent types only once satisfying the linearlity constraint.

\begin{center}
\begin{varwidth}{\linewidth}
\begin{verbatim}
	proc r :: A | X => Z = 
		    a, b | x => z -> 
			    plug 
				       p(a | x => y)
				       q(a | y => z)
\end{verbatim}
\end{varwidth}
\end{center}

The {\tt plug} command can only occur as the last command in a process block, and causes the plugged processes to run. Two processes plugged together can communicate and pass
messages through the connecting channel in both directions. CaMPL allows utmost one channel to be used connect two processes. 

The sequent calculus version of the above program is as follows:
\[ \infer[\text{cut}]{A, B ~|~ X \vvdash Z}{A ~|~ X \vvdash Y \quad \quad B ~|~ Y \vvdash Z } \]

Note that, a process is allowed to utilize a channel type only once, neither can it create new channel, unless using the {\tt plug} command. Example ?? describes one such usage of {\tt plug} and {\tt neg} commands for process invocation (See Section \ref{sec:neg} for {\tt neg} command).  

\subsection{Equating channels using {\tt id} and {\tt neg}}
\label{sec:neg}

The {\tt id} command is used equate to two channels of opposite polarities while {\tt neg} command is used to equate two channel of same polarities. The following code snippet demonstrates the usage of these commands:
\begin{center}
	\begin{varwidth}{\linewidth}
		\begin{verbatim}
			proc q :: | A, Neg(A) => A = 
					  | a, neg_a => a' -> 
					       a |=| a'						                    -- equating
					       neg_a |=| neg(a)                  -- equating after negating
		\end{verbatim}
	\end{varwidth}
\end{center} 

\subsection{Ending communication using {\tt halt} and {\tt close}}

\begin{center}
	\begin{varwidth}{\linewidth}
		\begin{verbatim}
			 close <channel_1>
			 close <channel_2>
			 ...
			 halt <channel_n>		 
		\end{verbatim}
	\end{varwidth}
\end{center} 

\vspace{-1em}

A process may use {\tt close} and the {\tt halt} commands to close its channels. The {\tt halt} command halts a process after closing the last channel (to be closed). The {\tt halt} command is expected to be the last command of a process block. Closing a channel of any (co)protocol type results in built-in channel type {\tt TopBot}.

In Example {\bf EchoServer} in Section ??,  line ??, {\tt EchoClose} handle creates a channel of type {\tt TopBot}. The {\tt client} process, closes the channel {\tt ch} and halts, using {\tt halt} command (line ??), after {\tt hput EchoClose on ch} (line ??). 
 
\subsection{Paired constructs }
\label{subsec:pairs}

\subsubsection{Sending and receiving messages using {\tt send} and {\tt recv}}
\label{subsec:put-get}

The semantics of message passing in CaMPL is given by a linear actegory. The operator $\circ$ 
in linear actegory corresponds to the {\tt Put(A|Ch)} and the operator $\bullet$ corresponds to 
the {\sf Get(A|Ch)} channel types. A process may perform {\tt send} and {\tt recv} commands on 
a channel of type either {\tt Put(A|Ch)} and {\tt Get(A|Ch)}.

\begin{figure}
\[  
 [{\tt Put}]: \quad \xymatrix{   
 \blackman  \quad
 \ar[rr]^{(r) \quad A \circ X \quad (l)}  
 &  & \quad \blackman   } \quad \quad \quad 
 [{\tt Get}]: \quad\xymatrix{  
 \blackman  \quad
 \ar@{<-}[rr]^{(r) \quad B \bullet X \quad (l)} 
 &  & \quad \blackman   }  
 \]
 \caption{Schematic of {\tt Put} and {\tt Get} types}
 \label{Fig: Put and Get}
\end{figure}

Given a channel of type $A \circ X$ or \texttt{Put(A|X)}, a process may:
\begin{itemize}
	\item {\em send} a message of type {\tt A} over a right polarity (output) channel, and
	\item {\em receive} a message of {\tt A} over a left polarity (input) channel.
\end{itemize}

Dually, given a channel of type $B \bullet X$, a process may:
\begin{itemize}
	\item {\em send} a message of type {\tt A} over a left polarity (input) channel, and
	\item {\em receive} a message of {\tt A} over a right polarity (output) channel.
\end{itemize}

This means that over a channel of type {\tt Put(A|Ch)}, data of type {\tt A} flows towards the right.  This means that over a channel of type {\tt Get(A|Ch)}, data of type {\tt A} flows towards the left.  

\begin{figure}[h]
\begin{center}
	\begin{varwidth}{\linewidth}
		\begin{verbatim}
			Put( <sequential_type> | <concurrent_type> )
		\end{verbatim}
	\end{varwidth}

	\begin{varwidth}{\linewidth}
		\begin{verbatim}
			Get( <sequential_type> | <concurrent_type> )
		\end{verbatim}
	\end{varwidth}
\end{center}
\vspace{-2em}
\caption{Syntax for {\tt Put} and {\tt Get}}
\label{Fig: Put and Get syntax}
\end{figure}

% Side-by-side figures
\begin{figure}[h]
\begin{minipage}{.5\textwidth}
	\[ \infer[\circ_R]{B ~|~ X \dashvv A' \circ Y}{A \dashv A' \quad A, B ~|~ X \dashvv Y} \]
	\[ \infer[\circ_L]{A ~|~ B \circ X \dashvv Y}{A,B ~|~ X \dashvv Y} \]
  	\vspace{-2em}
  \captionof{figure}{Sequent rules for Put}
  \label{Fig: sequent rules for Put}
\end{minipage}%
\begin{minipage}{.5\textwidth}
	\[ \infer[\bullet_R]{B ~|~ X \dashvv A \circ Y}{A,B ~|~ X \dashvv Y} \]
	\[ \infer[\bullet_L]{A ~|~ B' \bullet X \dashvv Y}{B \dashv B' \quad \quad A,B ~|~ X \dashvv Y} \]
	\vspace{-2em}
  \captionof{figure}{Sequent rules for Get}
  \label{Fig: sequent rules for Get}
\end{minipage}
\end{figure}

Figure \ref{Fig: Put process} shows a sample communication over a channel of \texttt{Put(A|Ch)} 
type. Process \texttt{p} sends the string ``Sending on output channel" which is received by 
process \texttt{q}. 
Dually, in Figure \ref{Fig: Get process}, Process \texttt{q} sends a string ``Sending on input 
channel" which is received by \texttt{q}. 

% Side-by-side figures
\begin{figure}[h]
\centering
\begin{minipage}{.5\textwidth}
	\begin{verbatim}
		proc p :: A | => Put( [Char] | Y ) = 
			a | => y -> do
				send "Sending on output channel" on y
				halt y
			
		proc q ::  | Put( [Char] | Y ) =>  = 
			| y => do
				recv b on y
				halt y

	\end{verbatim}
  	\vspace{-3em}
  \captionof{figure}{Send-Receive via \texttt{Put}}
  \label{Fig: Put process}
\end{minipage}%
\begin{minipage}{.5\textwidth}
  \centering
	\begin{verbatim}
		proc q :: A | Get( [Char] | Y ) => = 
			a | y => -> do
				send "Sending on input channel" on y
				halt y
			
		proc p ::  | => Get( [Char] | Y )  = 
			| => y do
				recv b on y
				halt y

	\end{verbatim}
	\vspace{-3em}
  \captionof{figure}{Send-Receive via \texttt{Get}}
  \label{Fig: Get process}
\end{minipage}
\end{figure}

In Example {\bf EchoServer} in Section ??, in line ??, the handle {\tt EchoSend} constructs a channel of {\tt Put-Get} type allowing the {\tt server} to receive and send in sequence (or vice versa for the {\tt Client}).

The above described usage of \texttt{Put} and \texttt{Get} channel types apply for channels which are instances of Protocols. For coProtocols, the role of {\tt Put} and {\tt Get} gets reversed, as shown in the following tables:
\begin{center}
	\begin{tabular}{ c || c | c }
		     (P)       & (r) & (l) \\
		 \hline
		 \hline      
		 {\tt Get}  & {\tt recv}  & {\tt send} \\
		 \hline
		 {\tt Put}  & {\tt send}  & {\tt recv} 
	\end{tabular}
	\quad \quad 
	\begin{tabular}{ c || c | c }
		     (coP)       & (r) & (l) \\
		 \hline
		 \hline      
		 {\tt Get}  & {\tt send}  & {\tt recv} \\
		 \hline
		 {\tt Put}  & {\tt recv}  & {\tt send} 
	\end{tabular}
\end{center}

Read this as, if I (process) have an output channel which is a {\tt Put} type on a protocol, then I can {\tt send} (put) data on this channel. Alternatively, if I (process) have an input channel which is a {\tt Put} type on a protocol, then someone will be {\tt send}ing (putting) data on this channel for me.

If I (process) have an input channel which is a {\tt Get} type on a protocol, then I can {\tt recv} (get) data on this channel. Alternatively, if I (process) have an output channel which is a {\tt Get} type on a protocol, then someone will be {\tt recv}ing (getting) data on this channel from me.

\subsubsection{Activating channels using {\tt hcase} and {\tt hput}}

The {\tt hput} command sends a handle of a protocol over a right polarity channel which is matched by a {\tt hcase} command on the left polarity. For co-protocols, handles are sent over a left polarity channel and received over the corresponding right polarity channel. Figure \ref{Fig: hput and hcase} shows the syntax for {\tt hput} and {\tt hcase}.

\begin{figure}[h]
\begin{center}
	\begin{varwidth}{\linewidth}
		\begin{verbatim}
			hput <handle_name> on <channel_name>	
		\end{verbatim}
	\end{varwidth}

	\begin{varwidth}{\linewidth}
		\begin{verbatim}
			hcase <channel_name> of
				<handle1> -> ... 
				<handle2> -> ... 
				.
				.
				<handlen> -> ... 
		\end{verbatim}
	\end{varwidth}
\end{center}
\vspace{-2em}
\caption{Syntax for {\tt hput} and {\tt hcase}}
\label{Fig: hput and hcase}
\end{figure}

For example, in line ?? of the program shown in Section \ref{}, the {\tt Client}  hputs {\tt EchoClose} on channel {\tt ch} of type {\tt Echo}. This {\tt hput} is matched by {\tt hcase} in line ?? of the {\tt Server}. 


\subsubsection{Multichannel communication using {\tt split} and {\tt fork}}

\begin{figure}[h]
\begin{center}
	\begin{varwidth}{\linewidth}
		\begin{verbatim}
			fork <bundled_channel> as 
				<new_ch1> [with <channels>] -> <process1>
				<new_ch2> [with <channels>] -> <process2>
		\end{verbatim}
	\end{varwidth}

	\begin{varwidth}{\linewidth}
		\begin{verbatim}
			split <bundled_ch> into <new_ch1>, <new_ch2>
		\end{verbatim}
	\end{varwidth}
\end{center}
\vspace{-2em}
\caption{Syntax for fork and split}
\label{Fig: fork and split}
\end{figure}

The underlying mathematics of CaMPL allows plugging two processes along utmost one channel to avoid cycles. However, if one wishes to plug processes along more than one channel, one may do so safely (with no deadlocking) using {\sf split} and {\sf fork}. The tensor $(*)$ and the par $(+)$ functors (operators) bundles two or more channels together, and produces a new channel for communication (in linear actegories, $(*)$ and $(+)$ are written as $\otimes$ and $\oplus$ respectively).

If a process has a right polarity channel of type $A (*) B$, then it can {\sf fork} into two processes with two distinct channels $A$ and $B$ of right polarity. Dually, if a process is has a left polarity channel of type $A (+) B$, then it can {\sf fork} into two processes with two distinct channels $A$ and $B$ of left polarity. {\sf fork} is a non-blocking call. Accordingly, sequent rules for for fork are shown in Figure \ref{Fig: sequent rules fork}:
\begin{figure}[h]
	\[ \infer[\otimes_R]{A, B ~|~ X1, X2 \dashvv Y1 \otimes Y2}{A ~|~ X1 \dashvv Y1 \quad \quad B ~|~ X2 \dashvv Y2}  \quad \quad \quad \quad \quad \quad \infer[\oplus_L]{A,B ~|~ X1 \oplus X2 \dashvv Y1, Y2}{A ~|~ X1 \dashvv Y1 \quad \quad B ~|~ X2 \dashvv Y2} \]
\vspace{-2em}
\caption{Sequent rules for {\tt fork}}
\label{Fig: sequent rules fork}
\end{figure}

Figures \ref{Fig: fork1} show a process {\sf p} with a right polarity channel of type $Y1 (*) Y2$. Using the compound channel, the process forks into a process {\sf p} and a process {\sf q}. Similarly, Figure \ref{Fig: fork2} is an example of process forking.

% Side-by-side figures
\begin{figure}[h]
\centering
\begin{minipage}{.5\textwidth}
	\begin{verbatim}
		proc p :: A, B | X1, X2 => Y1 (*) Y2 = 
			a, b | x1, x2 => y -> 
				fork y as 
					y1 -> p(a | x1 => y1)
					y2 -> q(b | x2 => y2)
	\end{verbatim}
  	\vspace{-2em}
  \captionof{figure}{Process forking using {\tt (*)}}
  \label{Fig: fork1}
\end{minipage}%
\begin{minipage}{.5\textwidth}
  \centering
	\begin{verbatim}
		proc p :: A, B | X1 (+) X2 => Y1 ,Y2 = 
			a, b | x => y1, y2 -> 
				fork x as 
					x1 -> p(a | x1 => y1)
					x2 -> q(b | x2 => y2)
	\end{verbatim}  
	\vspace{-2em}
  \captionof{figure}{Process forking using {\tt (+)}}
  \label{Fig: fork2}
\end{minipage}
\end{figure}

If a process is connected to a left polarity channel of type {\tt A (*) B}, then it can {\sf split} the bundle into two distinct channels {\tt A} and {\tt B} of left polarity to be used by the process for further computations. Dually, if a process is connected to a right polarity channel of type {\tt A (+) B}, then it can {\sf split} the bundle into two two distinct channels {\tt A} and {\tt B} of right polarity. {\sf split} is a blocking call --- that is a process calling split will be blocked unless a {\sf fork} occurs at the other end of the same channel.

The sequent rules for {\sf split call} are shown in Figure \ref{Fig: sequent rules for split}.

\begin{figure}[h]
	\[ \infer[\otimes_R]{A ~|~ X1 \dashvv Y1 \oplus Y2}{A ~|~ X1 \dashvv Y1, Y2} \quad \quad \quad \quad \quad \quad \infer[\oplus_L]{A ~|~ X1, X2 \dashvv Y1}{A ~|~ X1 \otimes X2 \dashvv Y1} \]
\vspace{-2em}
\caption{Sequent rules for {\tt split}}
\label{Fig: sequent rules for split}
\end{figure}

Figure \ref{Fig: split1} shows a process {\sf q} splitting an left polarity and calling a process $p$. Dually, Figure \ref{Fig: split2} shows a process splitting on the right polarity.

% Side-by-side figures
\begin{figure}[h]
\centering
\begin{minipage}{.5\textwidth}
	\begin{verbatim}
		proc p :: A | X => Y1, Y2 = 
			a | x => y1, y2 -> ... 
			
		proc q :: A | X => Y1 (+) Y2 = 
			a, b | x => y -> do
					split y into y1, y2
					p( a | x => y1,y2)
	\end{verbatim}
  	\vspace{-2em}
  \captionof{figure}{Process splitting at the right polarity}
  \label{Fig: split1}
\end{minipage}%
\begin{minipage}{.5\textwidth}
  \centering
	\begin{verbatim}
		proc p :: A | X => Y1, Y2 = 
			a | x => y1, y2 -> ... 
		
		proc q :: A | X1 (*) X2 => Y = 
			a, b | x => y -> do
					split x into x1, x2
					p( a | x1,x2 => y)
	\end{verbatim}
	\vspace{-2em}
  \captionof{figure}{Process splitting at the left polarity}
  \label{Fig: split2}
\end{minipage}
\end{figure}

In Example ??, ... 

\subsection{Non-deterministic communication using {\tt race}}

\begin{center}
	\begin{varwidth}{\linewidth}
		\begin{verbatim}
			race 
				<ch_1> -> ...
				<ch_2> -> ...
				..
				<ch_n> -> ...
		\end{verbatim}
	\end{varwidth}
\end{center}

The {\tt race} command initiates a race condition between two or more channels of 
{\tt  Put(-|-)} type\footnote{ Desiderata: We could like to race on handles or any blocking call. Current compiler support is for {\tt Put}.}. 
The system waits for input on any of the racing channels and triggers the corresponding continuation for the first one to receive data. The continuations for the losing channels are discarded.

In Example ??,

\subsection{Higher-order message passing using {\tt store} and {\tt use}}

CaMPL supports higher-order processes, that is, allowing {\em process}es to be packaged and passed to other processes, thereby treating processes as ``first-class citizens".  It provides two constructs for this purpose, namely,  
\begin{itemize}
	\item {\tt store} converts a concurrent process into sequential data.
	\item {\tt use} allow the calling of a stored process.
\end{itemize}
CaMPL provides a sequential data type {\tt Store}$(\Phi|\Lambda \vvdash \Delta)$ to represent stored processes. The following program demonstrates higher-order message passing using the Store type and the constructs. Process {\tt q} calls the stored process {\tt p}, {\tt counter} number of times.
\begin{center}
	\begin{varwidth}{\linewidth}
		\begin{verbatim}
			proc q :: Int, Store( | A => A) | A => A = 
					   counter, stored_process | a1 => a2 -> 
					       case counter of 
						       0 -> x |=| y						                    -- base	case
						       _ -> plug 					                       -- recursive case
							         use(p)(| x => z)				               -- using the stored process
							         q(counter-1, p | z => y)		         -- recurse
		\end{verbatim}
	\end{varwidth}
\end{center}
The mathematics semantics of storing concurrent processes as sequential data is given by the equivalence between a right $\A$-actegory with Hom-objects and a right $\A$-enriched category with copowers, see \cite{Melika25}.

Another method of passing a process {\tt p} of type "{\tt | A => B}" to a process {\tt q} is using the channel type {\tt Neg(A) (+) B}. The channel type {\tt Neg(A) (+) B} encodes a process {\tt p} of type signature "{\tt | A => B}". Then, a process may "apply" the channel type "{\tt Neg(A) (+) B}" to a input channel of type {\tt A} to produce a output channel of type {\tt B}. The following code demonstrates this. 
\begin{center}
	\begin{varwidth}{\linewidth}
		\begin{verbatim}
			proc apply :: | A, Neg(A) (+) B => B =
				 | a, neg_a_b => b ->
				        fork neg_a_b as
				               neg_a -> neg_a |=| neg(a)
				               b' -> b |=| b' 
		\end{verbatim}
	\end{varwidth}
\end{center}
However, this method does not support arbitrary recursive definitions since channels are linear resources, hence cannot be duplicated (thereby disallowing multiple invocations of a received process). For example, consider a process {\tt q} that receives two input channels: one of type {\tt A} and another of type {\tt Neg(A) (+) A} (representing a process with type signature {\tt A => A}). Additionally, the process {\tt q} has a output channel of type {\tt A} and a sequential {\tt counter} of type {\tt Int}. The goal is to apply the input process to the input channel {\tt counter} times  possibly using the below code snippet. However, this code snippet is invalid in CaMPL since process {\tt q} uses the channel {\tt p} more than once , thereby, violating linearity constraint. 
\begin{center}
	\begin{varwidth}{\linewidth}
		\begin{verbatim}
			proc q :: Int | A, Neg(A) (+) A => A =
				 counter | a, p => y -> case counter of
				          0 -> a |=| y
				          _ -> plug
				          	     apply ( a, p => z )
					               q( counter - 1 | z, p => y )
		\end{verbatim}
	\end{varwidth}
\end{center}


Note that the above method for higher-order message passing behavior is implicit to CaMPL and uses no new instructions. This is due to the fact that the concurrent side of MPL is a $*$-autonomous category. This allows the language to inherently support (non-recursive) higher-order behavior as described by the following sequent rule,
\[ 
	\infer{\Lambda \vvdash A^\perp \oplus B := A \lollipop B}{\Lambda, A \vvdash B}
\]
	
\section{Example programs}

\subsection*{Hello World}

In this example, a CaMPL process prints ``Hello World" using an input console channel.The console is a special coprotocol channel hard-coded in the compiler which connects to the  terminal from which the program is run.
\begin{center}
	\begin{varwidth}{\linewidth}
		\begin{verbatim}
			proc helloworld :: | Console => = 
			    | console => -> do
			        hput ConsolePut on console               
			        put "Hello World" on console.              
			
			        hput ConsoleClose on console 
			        halt console
		\end{verbatim}
	\end{varwidth}
\end{center}
The {\tt helloworld} process is invoked as follows:
\begin{center}
	\begin{varwidth}{\linewidth}
		\begin{verbatim}
			proc run = 
			    | console => -> helloworld( |console=>)
		\end{verbatim}
	\end{varwidth}
\end{center}			    

\subsection{EchoServer}

\subsection*{Expected program behavior} There are two processes {\em a client} and {\em a server} communicating with one another. The server is connected to the environment via a console, and the client via a \texttt{StringTerminal}. The server reads a string from the terminal, relays it to the server who prints it on the console, and sends the string back to the client. When the user provides an empty string, the processes terminate. 

The topology of the processes and their connection remains the same throughout the program. The topology is shown in the diagram below:
<DIAGRAM>


\subsection*{CaMPL program}
The main protocol used in this program is \texttt{Echo}. It provides a handle \texttt{EchoSend} of Put-Get type which will be used to send-receive or receive-send a message depending on the polarity of channel ends. The handle \texttt{EchoClosed} is used to close a channel of \texttt{Echo} type. 

\begin{verbatim}
protocol Echo => S =
    EchoSend :: Put( [Char] | Get( [Char] | S)) => S
    EchoClose :: TopBot => S
\end{verbatim}

The client process is connected to a channel of \texttt{Echo} type at the output end. It first reads a string (provided by the user) from the terminal. If the user provided a non-empty string, it will place \texttt{EchoSend} handle on the channel followed by a \texttt{put} to send the string. Then, it performs a (blocking) \texttt{get} to receive data from server and loops. If the use provided an empty string, it signals the server by placing the \texttt{EchoClose} handle on the channel. It closes its connection and terminates.

\begin{verbatim}

proc client :: | => Echo, ClientConsole =
    | => ch, console -> do
        hput StringTerminalGet on console
        get fruit on console

        case fruit of
            [] -> do
                hput EchoClose on ch
                hput StringTerminalClose on console
                close console
                halt ch

            _:_ -> do
                hput EchoSend on ch
                -- send data
                put fruit on ch 
                -- receive echoed data
                get echoed on ch  
                -- print received data
                hput StringTerminalPut on console
                put ('>':' ':echoed) on console

                -- loop
                client( | => ch, console)
\end{verbatim}    

The server process is connected to a channel of \texttt{Echo} type at the input end. It first performs a (blocking) \texttt{hcase}. If the handle received is \texttt{EchoSend}, then it receives data (sent by the client) using a {blocking} \texttt{get}. It sends the received data back as an acknowledgement using a \texttt{put} (since the handle \texttt{EchoSend} does Put-Get), and loops. If the handle received is \texttt{EchoClose} then it closes it connection with the channel and terminates. 

\begin{verbatim}
proc server :: | Echo, LogConsole => =
    | ch, console => -> do
        hcase ch of
            EchoSend -> do
                -- receive data
                get fruit on ch

                -- print data
                hput ConsolePut on console
                put fruit on console

                -- echo (send) data 
                put fruit on ch
                server( | ch, console => )
            EchoClose -> do
                hput ConsolePut on console
                put "Done" on console
                hput ConsoleClose on console
                close console
                halt ch
\end{verbatim}

The following is the code for ClientConsole and the server's LogConsole for reading input and printing output. 

\begin{verbatim}

protocol ClientConsole => S =
    StringTerminalGet :: Get( [Char] | S) => S
    StringTerminalPut :: Put( [Char] | S) => S
    StringTerminalClose :: TopBot => S

coprotocol S => LogConsole =
    ConsolePut :: S => Get( [Char] | S)
    ConsoleClose :: S => TopBot
\end{verbatim}

The following process  is the first process to be invoked by the program which initiates the topology, and runs the client and the server. 

\begin{verbatim}
proc run :: | LogConsole => ClientConsole =
    | console_s => console_c -> plug
        client( | => ch, console_c )
        server( | ch, console_s => )

\end{verbatim}

The following items were suggested by Hashimoto as improvements to CaMPL syntax:

\begin{itemize}
	\item While we have \texttt{Get} and \texttt{Put} for protocols (which means get and put on the output polarity), it will be user-friendly \texttt{coGet} and \texttt{coPut} for coprotocols (to mean \texttt{put} and \texttt{get} respectively on the output terminal.
	\item Racing on handles instead of \texttt{put}. So be able to race on \texttt{hput}, and \texttt{fork} handles.
	\item Merge the \texttt{hput} followed by the get or put. 
	\item \texttt{on <channel> hput <handle>} instead of \texttt{hput <handle> on <channel>}. 
	\item Currently, to halt a process, the channels are first closed and the final \texttt{halt <channel>} command takes in the name of the last channel to be closed. Instead, close all the channels followed by \texttt{halt} command.
\end{itemize}

\subsection{Mutual Exclusion}

This example simulates mutual exclusive access of a memory cell between two CaMPL processes tagged {\tt A} and {\tt B}.  

The example uses {\tt fork} and {\tt split} to pass a {\tt Mutex} channel type. Hence, new processes are created during program execution. However, the code primarily has three processes -- a process {\tt MemAccess} which reads and writes to the memory, a process {\tt MemWait}, and a Memory cell process. Process {\tt MemAccess} is connected to the Memory via an output channel. A {\tt Mutex} protocol is used communication for between the {\tt MemWait} and {\tt MemAccess} processes. Process {\tt MemWait} is connected to {\tt MemAccess} via {\tt Mutex} channel on output and input ends respectively. 

\[ \includegraphics[scale=0.1]{figs/MemCell.jpeg} \]

The competing `processes', say {\tt A} and {\tt B}, take turns running {\tt MemWait} and {\tt MemAccess}. To begin with Process {\tt A} starts with {\tt MemAccess} and process {\tt B} starts with {\tt MemWait}. Each process is connected to a string terminal to read user input.
Process {\tt A} blocks on {\tt hcase} waiting to receive a handle from Process {\tt B} on {\tt Mutex} channel.

Process {\tt B} (in {\tt MemWait}) sends {\tt Pass} handle to Process {\tt A} and blocks (on {\tt split}).  

On receiving the handle from Process {\tt B}, Process {\tt A} running {\tt MemAccess} accesses the memory cell -- by reading the existing value and the write a new value. 

On completing the read and write, Process {\tt A} forks on the input channel type {\tt Mutex} producing two input channels, {\tt MemCh} and {\tt Neg(Mutex)}. It equates the new {\tt MemCh} channel to the existing channel. Then it invokes {\tt MemWait} for which it negates the {\tt Neg(Mutex)} channel. Negating a channel of {\tt Neg(Mutex)} type results in a {\tt Mutex} type --- this is to convert the {\tt Mutex} channel from input to output polarity (Recall that {\tt Mutex} is of input channel type for {\tt MemAccess} and output channel type for {\tt MemWait}).

Once Process {\tt A} performs {\tt fork}, Process {\tt B} (in {\tt MemWait}) resumes and invokes {\tt MemAccess} to access the memory cell.

The rest of the section explains the code snippets. Complete code available in Appendix ??.

The protocol {\tt Mutex} has an input channel type {\tt M} and an output channel type {\tt S}. The handle {\tt Pass} type constructs from {\tt S} a compound {\tt (+)} channel. The protocol {\tt MemCh} is used communication between {\tt MemAccess} and Memory cell for reading, writing and closing a memory cell.

\begin{center}
\begin{varwidth}{\linewidth}
	\begin{verbatim}
		protocol Mutex( | M ) => S =
		    Pass :: M (+) Neg(S)  => S
		
		protocol MemCh (A | ) => S =
		    MemPut :: Put(A|S) => S
		    MemGet :: Get(A|S) => S
		    MemCls :: TopBot => S
			\end{verbatim}
\end{varwidth}
\end{center}
The process {\tt memCell} takes an input {\tt MemCh} channel, reads and writes to it.
\begin{center}
\begin{varwidth}{\linewidth}
	\begin{verbatim}
		proc memCell :: A | MemCh(A | ) => =
		    val | ch => -> hcase ch of
		        MemPut -> do
		            get nval on ch
		            memCell(nval | ch => )
		        MemGet -> do
		            put val on ch
		            memCell(val | ch => )
		        MemCls -> do
		            halt ch
	\end{verbatim}
\end{varwidth}
\end{center}

Initially, the main process creates three processes {\tt memAccess} (with tag Process {\tt A:}), {\tt memWait} (with tag Process {\tt B:}), and a memory cell with an initial value. Note that, {\tt memAccess} is connected to the memory cell. 
\begin{center}
\begin{varwidth}{\linewidth}
	\begin{verbatim}
		proc run =
		    | => _strterm0, _strterm1 -> do
		        plug 
		            memAccess("A:" | mutex => mem, _strterm0)
		            memWait("B:" |        => mutex, _strterm1)
		            memCell( "I like dogs" | mem => )
	\end{verbatim}
\end{varwidth}
\end{center}

Process {\tt memWait} activates the {\tt Mutex} channel and splits it, hence blocking itself. Once it resumes (due to a {\tt fork}), it invokes {\tt memAccess} using {\tt plug}. The output {\tt Neg(Mutex)} needs to be negated to get an input {\tt Mutex} channel.
\begin{center}
\begin{varwidth}{\linewidth}
	\begin{verbatim}
	    proc memWait :: [Char] |  => Mutex( | MemCh([Char] | )), StringTerminal =
	        tag | => mutex, _strterm -> do
	            hput Pass on mutex
	            split mutex into mem, negmutex
	
	            plug
	                memAccess(tag | nmutex => mem, _strterm)
	                => negmutex, nmutex -> negmutex |=| neg nmutex
	\end{verbatim}
\end{varwidth}
\end{center}

Process {\tt memAccess} on receiving the {\tt Pass} handle on {\tt Mutex}, does read and write of the memory (lines ?? -- ??). Once memory access is complete, it forks on input channel {\tt Mutex} and invokes {\tt memWait} using {\tt plug}.

\begin{center}
\begin{varwidth}{\linewidth}
	\begin{verbatim}
    proc memAccess :: [Char] | Mutex( | MemCh([Char] | ) ) 
    	=> MemCh([Char]| ), StringTerminal =
        tag | mutex => mem, _strterm -> hcase mutex of 
            Pass -> do 
                hput MemGet on mem
                get inp on mem

                hput StringTerminalPut on _strterm
                put append(tag, " Receiving: ") on _strterm

                hput StringTerminalPut on _strterm
                put inp on _strterm

                hput StringTerminalPut on _strterm
                put append(tag, " Enter a string: ") on _strterm

                hput StringTerminalGet on _strterm
                get ninp on _strterm

                hput MemPut on mem
                put ninp on mem

                fork mutex as
                    mmem with mem -> mmem |=| mem

                    negmutex with _strterm -> do
                        plug
                            memWait(tag | => nmutex, _strterm)
                            nmutex, negmutex => -> negmutex |=| neg nmutex
	\end{verbatim}
\end{varwidth}
\end{center}

\subsection{Non-deterministic communication}

\section{Notes on the compiler and interface design}

CaMPL has concurrent and sequential types. Some useful tables and notes.

The following table summarizes the analogues of sequential and concurrent worlds.

\begin{center}
\begin{tabular}{ c | c | c | c }
 {\bf Sequential} & Datatypes  & Functions & Instances \\ 
   & (and coDatatypes)  &  &  \\
 \hline
 {\bf Concurrent} & Protocols & Processes & Channels \\  
 & (and coProtocols)  &  &  \\
\end{tabular}
\end{center}

Channels are instances of (co)protocols. Given a process and a channel {\em connected} to it, the channel may have input (+) or output polarity (-) for that process. 

Here are a few practical programming notes:
\begin{itemize}
	\item {\tt close} command closes a channel. {\tt halt} command is used on a process which has only one connected channel. Halt closes the channel and halts the process. 
	
	{\bf Design question:} Why not interpret closing all the channels as a signal to halt? For example: 
	\begin{verbatim}
		 close ch1  
		 close ch2  
		 halt
	\end{verbatim}
	
	\item The handles \tt{ConsoleGet}, \tt{ConsolePut}, \tt{ConsoleClose}, \tt{StringTerminalGet}, \tt{StringTerminalPut}, and \tt{StringTerminalClose} which are used for reading from and writing to terminals are hard-coded.  
	
\begin{center}
	\begin{tabular}{ c | c | c }
		     (P)       & (+) & (-) \\
		 \hline      
		 {\tt Get}  & {\tt get}  & {\tt put} \\
		 \hline
		 {\tt Put}  & {\tt put}  & {\tt get} 
	\end{tabular}
	\quad \quad 
	\begin{tabular}{ c | c | c }
		     (coP)       & (+) & (-) \\
		 \hline      
		 {\tt Get}  & {\tt put}  & {\tt get} \\
		 \hline
		 {\tt Put}  & {\tt get}  & {\tt put} 
	\end{tabular}
	\quad \quad 
	\begin{tabular}{ c | c | c }
		            & (+) & (-) \\
		 \hline      
		 (P)  & {\tt hput}  & {\tt hcase} \\
		 \hline
		 (coP)  & {\tt hcase}  & {\tt hput} 
	\end{tabular}
\end{center}
 
\end{itemize}

\section{Mathematical Underpinning}

\subsection{Category Theory}

The mathematical semantics of CaMPL is modeled by a {\em linear actegory} \cite{CoP07}:4.2 where a symmetric monoidal categorical category $\X$ --- representing the semantics of of the sequential side --- acts on a symmetric linearly distributive category $\C$ --- representing the semantics of the concurrent side. This interaction is defined by two action functors:

\[ \circ: \A \times \C \to \C \quad \quad \text{ and } \quad \quad \bullet: \A^{\sf op} \times \C \to \C \]

These functors describe how sequential data, or {\em messages}, are transmitted through {\em channels}, which are modeled as concurrent types. The $\circ$ functor is the left parametrized left adjoint of $\bullet$ in the sense that the following is a parametrized adjunction:

\[ A \in \A,  \quad X \circ - \dashv A \bullet - : \C \to \C \]

The adjunction signifies that a process transmitting or receiving a message can do so from either end of a channel. 

\subsection{Message Passing Logic}

The message passing logic, {\bf Msg}, gives a type system for concurrent proccesses which use message passing as their concurrency primitive \cite{CoP07}. The logic they introduced is two-tiered with rules governing the interaction of the two tiers. The two-tiers include the logic of messages and logic of message-passing.

\subsubsection{The logic of messages}

This tier concerned with generation of messages represents the logic of computation, and corresponds to the type system for sequential computation. The proofs in this logic correspond to sequential programs. The logic is presented in a Gentzen sequent style: a sequent takes the form
\[ \Phi \vdash A \]
where the {\em antecedent} (which we will also call the {\em context}) of $\Phi$ is a comma-separated list of formulas and the {\em succedent} $A$ is a single formula. The term calculus for this logic is given in Figure \ref{Fig:MsgRules}. In the inference rules, {\em subs} stands for substitution and is the cut rule. 

\begin{figure}
\centering
	\includegraphics[scale=0.5]{figs/MsgRules.PNG}
	\caption{Inference rules for {\bf Msg}}
	\label{Fig:MsgRules}
\end{figure}

\subsubsection{The logic of message-passing}
	
	The logic of message, {\bf PMsg}, passing concerned with communication over channels represents the logic of communication, and is concerned with channels over which processes communicate messages. A sequent of {\bf PMsg} has three components all of which are unordered lists: list $\Phi$ of message types, list $\Lambda$ of left polarity channels, and list $\Delta$ of right polarity channels which, together define a sequent of PMsg: 
\[ \Phi ~|~ \Lambda \vvdash \Delta \]	
The inference rules for {\bf PMsg} are presented in Figure \ref{Fig:PMsgRules}. Most of the rules of this calculus are standard ones for two-sided multiplicative linear logic except the {\em action} rules $\circ_l$, $\circ_r$, $\bullet_l$, and $\bullet_r$ which allow messages to be bound to channels of interaction.
\begin{figure}
\centering
	\includegraphics[scale=0.6]{figs/PMsgRules.PNG}
	\caption{Inference rules for {\bf PMsg}}
	\label{Fig:PMsgRules}
\end{figure}
	
Thus, the message passing logic provides a clean separation of computation and communication layers thereby allowing the complexities associated with each layer to be addressed effectively. Figure \ref{Fig:programming-syntax} provides the programming syntax for CaMPL.
\begin{figure}
\centering
	\includegraphics[scale=0.6]{figs/programming-syntax.png}
	\caption{Programming syntax for {\bf PMsg}}
	\label{Fig:programming-syntax}
\end{figure}





\end{document}
