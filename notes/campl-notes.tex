\documentclass[11pt]{article}
\input{preamble}
\input{macros}
\addbibresource{refs.bib}
\linespread{1.11}

\title{Categorical Message Passing Language (CaMPL)}
\author{
    Robin Cockett\thanks{University of Calgary} \and Daniel Hashimoto\thanks{Universidade Federal do Rio de Janeiro} \and Priyaa Varshinee Srinivasan\thanks{Tallinn University of Technology}}
%\def\authorrunning{D.\ I.\ Spivak \& P.\ V.\ Srinivasan}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
This document is a simple introduction to  a novel concurrent programming language called the 
categorical message passing language built on the mathematics of linear actegories. 
Categorical Message Passing Language, to the best of our knowledge, 
the only\footnote{Is this true?} concurrent programming language with mathematical underpinnings. 
It is a functional-style programming language with the abstract machine built on Haskell. 
The current version of CaMPL compiler is to be considered a proto-alpha, a proof-of-concept 
of language built from the mathematics of linear actegories.
\end{abstract}

%\addcontentsline{toc}{section}{References}

\tableofcontents

\section{Introduction}

Explain current state of concurrency and why CaMPL is novel, and its history.

\section{Mathematical Underpinning}

The categorical semantics of CaMPL is modeled by a {\em linear actegory} \cite{..}, where a symmetric monoidal categorical category $\X$ --- representing the semantics of of the sequential side --- acts on a symmetric linearly distributive category $\C$ --- representing the semantics of the concurrent side. This interaction is defined by two action functors:

\[ \circ: \A \times \C \to \C \quad \quad \text{ and } \quad \quad \bullet: \A^{\sf op} \times \C \to \C \]

These functors describe how sequential data, or {\em messages}, are transmitted through {\em channels}, which are modeled as concurrent types. The $\circ$ functor is the left parametrized left adjoint of $\bullet$ in the sense that 

\[ A \in \A,  \quad X \circ - \dashv A \bullet - : \C \to \C \]

and this parametrized adjunction. The adjunction signifies that a process transmitting or receiving a message can do so either end of a channel. 

\[ \includegraphics[scale=0.5]{figs/term-rules.png} \]

\[ \includegraphics[scale=0.5]{figs/programming-syntax.png} \]

\section{CaMPL constructs and keywords}

CaMPL has concurrent and sequential types.

\subsection{Sequential types}

\subsection{Concurrent types}

A semantics of the concurrent side of CaMPL is given by a linearly distributive category $\C$ which comes with two monoidal structures $\otimes$ (tensor) and $\oplus$ (par). In this category, objects are concurrent channel types and morphisms are processes between channels.  

\subsection*{Protocols and co-protocols}

In CaMPL, channels are instances of protocols (similar to variables are instances of data types) and co-protocols. 

A protocol of sequential input type of $A$, 

\subsection*{Processes}

A process comes with an optional list of:
\begin{itemize}
	\item sequential input types;
	\item left polarity channels;
	\item right polarity channels.
\end{itemize}
For example, Figure \ref{fig:proc} shows a process \texttt{p} with a sequential input of type $A$, a left polarity channel of type $X$, and a right polarity channel of type $Y$ as defined in CAMPL (Process \texttt{p} is connected to the right end of \texttt{x} and to the left end of {\tt y}). It can be equivalently expressed as a circuit diagram, show in Figure \ref{fig:proc circuit} and the sequent calculus shown in Figure \ref{fig:proc sequent}. The black dot at the lower end of the input wire in the circuit diagram indicates the wire carries a sequential input. 

% Side-by-side figures
\begin{figure}[h]
\centering
\begin{minipage}{.5\textwidth}
  \begin{verbatim}
  	proc p :: A | X => Y =
	a | x => y -> ...
  \end{verbatim} 
  \captionof{figure}{Syntax for defining a process}
  \label{fig:proc}
  
  \vspace{1em}
  
  \[  A ~|~ X ~\dashvv~ Y \]
  \captionof{figure}{Sequent calculus}
  \label{fig:proc sequent}  
\end{minipage}%
\begin{minipage}{.5\textwidth}
  \centering
  \[ \includegraphics[scale=0.5]{figs/process-circuit.PNG} \]
  \captionof{figure}{Circuit diagram}
  \label{fig:proc circuit}
\end{minipage}
\end{figure} 

\subsection{Concurrent constructs}

Table \ref{tab:mpl-constructs} summarizes the operations on the concurrent types.

 \begin{table}[!h]
\centering
	\begin{tabular}{|l|l|l|}
	\hline
	\textsf{id} & equates two channels &  non-blocking  \\ \hline
	\textsf{neg} & negates a channel & non-blocking \\ \hline
	\textsf{plug} & connects two processes by a channel & non-blocking \\ \hline
	\textsf{Get} & send/receive a message on a channel & depends on the polarity \\ \hline
	\textsf{Put} & send/receive a value on a channel &  depends on the polarity \\ \hline
	\textsf{hput} & puts a handle on a channel & non-blocking \\ \hline
	\textsf{hcase} & cases on the handles obtained on channel & blocking \\ \hline
	\textsf{split} & splits a channel into two channels  & blocking\\ \hline
	\textsf{fork} & forks two new processes & non-blocking \\ \hline
	\textsf{close} & closes a channel & non-blocking \\ \hline
	\textsf{halt} & closes a channel. Usually the last channel is halted. & non-blocking \\ \hline
	\end{tabular}
\caption{Concurrent MPL Constructs}
\label{tab:mpl-constructs}
\end{table} 


\subsection*{{\sf plug} connects processes}

Composition of two processes in the concurrent side of CaMPL is defined by 
{\em plug} command (which is the {\em cut} rule in linear logic. 
When two processes that are running in parallel are plugged to each other 
along a channel, they can communicate and pass
messages through that channel in both directions. Two processes can only be plugged to
each other along a channel, if they both have a channel of the same type but opposite
polarity. One channel can be used to connect exactly two processes. 

The following program plugs process \texttt{p} with process \texttt{q} via channel \texttt{y}. For Process \texttt{p}, channel \texttt{y} has right polarity while for process \texttt{q} the same channel has left polarity.

\begin{center}
\begin{varwidth}{\linewidth}
\begin{verbatim}
	proc r :: A, B | X => Z = 
		a, b | x => z -> 
			plug 
				p(a | x => y)
				q(b | y => z)
\end{verbatim}
\end{varwidth}
\end{center}

The sequent calculus version of the above program is as follows:
\[ \infer[cut]{A, B ~|~ X \dashvv Z}{A ~|~ X \dashvv Y \quad \quad B ~|~ Y \dashvv Z } \]


\subsection*{{\sf Split} and {\sf Fork}}

\begin{figure}[h]
\begin{center}
	\begin{varwidth}{\linewidth}
		\begin{verbatim}
			fork <bundled_channel> as 
				<new_ch1> [with <channels>] -> <process1>
				<new_ch2> [with <channels>] -> <process2>
		\end{verbatim}
	\end{varwidth}

	\begin{varwidth}{\linewidth}
		\begin{verbatim}
			split <bundled_ch> into <new_ch1>, <new_ch2>
		\end{verbatim}
	\end{varwidth}
\end{center}
\vspace{-2em}
\caption{Syntax for fork and split}
\label{Fig: fork and split}
\end{figure}

As mentioned earlier, the underlying mathematics allows plugging two processes along utmost one channel to avoid cycles. However, if one wishes to plug processes along more than one channel, one may do so safely (with no deadlocking) using {\sf split} and {\sf fork}. The tensor $(*)$ and the par $(+)$ functors (operators) bundles two or more channels together, and produces a new channel for communication (in linear actegories, $(*)$ and $(+)$ are written as $\otimes$ and $\oplus$ respectively).

If a process has a right polarity channel of type $A (*) B$, then it can {\sf fork} into two processes with two distinct channels $A$ and $B$ of right polarity. Dually, if a process is has a left polarity channel of type $A (+) B$, then it can {\sf fork} into two processes with two distinct channels $A$ and $B$ of left polarity. {\sf fork} is a non-blocking call. Accordingly, sequent rules for for fork are shown in Figure \ref{Fig: sequent rules fork}:
\begin{figure}[h]
	\[ \infer[\otimes_R]{A, B ~|~ X1, X2 \dashvv Y1 \otimes Y2}{A ~|~ X1 \dashvv Y1 \quad \quad B ~|~ X2 \dashvv Y2} \]
	\[ \infer[\oplus_L]{A,B ~|~ X1 \oplus X2 \dashvv Y1, Y2}{A ~|~ X1 \dashvv Y1 \quad \quad B ~|~ X2 \dashvv Y2} \]
\vspace{-2em}
\caption{Sequent rules for fork}
\label{Fig: sequent rules fork}
\end{figure}

Figures \ref{Fig: fork1} show a process {\sf p} with a right polarity channel of type $Y1 (*) Y2$. Using the compound channel, the process forks into a process {\sf p} and a process {\sf q}. Similarly, Figure \ref{Fig: fork2} is an example of process forking.

% Side-by-side figures
\begin{figure}[h]
\centering
\begin{minipage}{.5\textwidth}
	\begin{verbatim}
		proc p :: A, B | X1, X2 => Y1 (*) Y2 = 
			a, b | x1, x2 => y -> 
				fork y as 
					y1 -> p( a | x1 => y1)
					y2 -> q( b | x2 => y2)
	\end{verbatim}
  	\vspace{-2em}
  \captionof{figure}{Process forking using {\tt (*)}}
  \label{Fig: fork1}
\end{minipage}%
\begin{minipage}{.5\textwidth}
  \centering
	\begin{verbatim}
		proc p :: A, B | X1 (+) X2 => Y1 ,Y2 = 
			a, b | x => y1, y2 -> 
				fork x as 
					x1 -> p( a | x1 => y1)
					x2 -> q( b | x2 => y2)
	\end{verbatim}  
	\vspace{-2em}
  \captionof{figure}{Process forking using {\tt (+)}}
  \label{Fig: fork2}
\end{minipage}
\end{figure}

If a process is connected to a left polarity channel of type {\tt A (*) B}, then it can {\sf split} the bundle into two distinct channels {\tt A} and {\tt B} of left polarity to be used by the process for further computations. Dually, if a process is connected to a right polarity channel of type {\tt A (+) B}, then it can {\sf split} the bundle into two two distinct channels $A$ and $B$ of right polarity. {\sf split} is a blocking call --- that is a process calling split will be blocked unless a {\sf fork} occurs at the other end of the same channel.

The sequent rules for {\sf split call} are shown in Figure \ref{Fig: sequent rules for split}.

\begin{figure}[h]
	\[ \infer[\otimes_R]{A ~|~ X1 \dashvv Y1 \oplus Y2}{A ~|~ X1 \dashvv Y1, Y2} \]
	\[ \infer[\oplus_L]{A ~|~ X1, X2 \dashvv Y1}{A ~|~ X1 \otimes X2 \dashvv Y1} \]
\vspace{-2em}
\caption{Sequent rules for fork}
\label{Fig: sequent rules for split}
\end{figure}

Figure \ref{Fig: split1} shows a process {\sf q} splitting an left polarity and calling a process $p$. Dually, Figure \ref{Fig: split2} shows a process splitting on the right polarity.

% Side-by-side figures
\begin{figure}[h]
\centering
\begin{minipage}{.5\textwidth}
	\begin{verbatim}
		proc p :: A | X => Y1, Y2 = 
			a | x => y1, y2 -> ... 
			
		proc q :: A | X => Y1 (+) Y2 = 
			a, b | x => y -> do
					split y into y1, y2
					p( a | x => y1,y2)
	\end{verbatim}
  	\vspace{-2em}
  \captionof{figure}{Process splitting at the output end}
  \label{Fig: split1}
\end{minipage}%
\begin{minipage}{.5\textwidth}
  \centering
	\begin{verbatim}
		proc p :: A | X => Y1, Y2 = 
			a | x => y1, y2 -> ... 
		
		proc q :: A | X1 (*) X2 => Y = 
			a, b | x => y -> do
					split x into x1, x2
					p( a | x1,x2 => y)
	\end{verbatim}
	\vspace{-2em}
  \captionof{figure}{Process splitting at the input end}
  \label{Fig: split2}
\end{minipage}
\end{figure}

\subsection*{{\sf Put} and {\sf Get} for sending and receiving messsages}

\begin{figure}[h]
\begin{center}
	\begin{varwidth}{\linewidth}
		\begin{verbatim}
			Put( <sequential_type> | <concurrent_type> )
		\end{verbatim}
	\end{varwidth}

	\begin{varwidth}{\linewidth}
		\begin{verbatim}
			Get( <sequential_type> | <concurrent_type> )
		\end{verbatim}
	\end{varwidth}
\end{center}
\vspace{-2em}
\caption{Syntax for Put and Get}
\label{Fig: fork and split}
\end{figure}

The semantics of message passing in CaMPL is given by a linear actegory. The operator $\circ$ in linear actegory corresponds to the {\sf Put} and the operator $\bullet$ corresponds to the {\sf Get} in CaMPL.Given channel of type $A \circ X$ or \texttt{Put(A | X)} means that process connected to its output end may send a message of type $A$ to the process connected to the input end. 

Figure \ref{Fig: sequent rules for Put} shows the sequent rules for \texttt{Put}. 

% Side-by-side figures
\begin{figure}[h]
\begin{minipage}{.5\textwidth}
	\[ \infer[\circ_R]{B ~|~ X \dashvv A' \circ Y}{A \dashv A' \quad A, B ~|~ X \dashvv Y} \]
	\[ \infer[\circ_L]{A ~|~ B \circ X \dashvv Y}{A,B ~|~ X \dashvv Y} \]
  	\vspace{-2em}
  \captionof{figure}{Sequent rules for Put}
  \label{Fig: sequent rules for Put}
\end{minipage}%
\begin{minipage}{.5\textwidth}
	\[ \infer[\bullet_R]{B ~|~ X \dashvv A \circ Y}{A,B ~|~ X \dashvv Y} \]
	\[ \infer[\bullet_L]{A ~|~ B' \bullet X \dashvv Y}{B \dashv B' \quad \quad A,B ~|~ X \dashvv Y} \]
	\vspace{-2em}
  \captionof{figure}{Sequent rules for Get}
  \label{Fig: sequent rules for Get}
\end{minipage}
\end{figure}

Figure \ref{Fig: Put process} shows a sample communication via the \texttt{Put} type. Process \texttt{p} has a right polarity channel {\tt y} while process \texttt{q} has a left polarity channel \texttt{y}, both of type \texttt{Put([Char]|X)}. 
Process \texttt{p} sends the string ``Hello" using \texttt{send} on its channel \texttt{y} which is received by process \texttt{q} on its channel {\tt y} using \texttt{recv}. 
Dually, in Figure \ref{Fig: Get process}, Process \texttt{p} has a left polarity channel {\tt y} while process \texttt{q} has a right polarity channel \texttt{y}, each of type \texttt{Get([Char]|X)}. 
Process \texttt{p} sends a string {\tt "Hello"} on \texttt{y} using \texttt{send} call and process \texttt{q} receives it on {\tt y} using the \texttt{recv} call. 

% Side-by-side figures
\begin{figure}[h]
\centering
\begin{minipage}{.5\textwidth}
	\begin{verbatim}
		proc p :: A | => Put( [Char] | Y ) = 
			a | => y -> do
				send "Hello" on y
				halt y
			
		proc q ::  | Put( [Char] | Y ) =>  = 
			| y => do
				recv b on y
				halt y

	\end{verbatim}
  	\vspace{-3em}
  \captionof{figure}{Send-Receive via \texttt{Put}}
  \label{Fig: Put process}
\end{minipage}%
\begin{minipage}{.5\textwidth}
  \centering
	\begin{verbatim}
		proc p :: A | Get( [Char] | Y ) => = 
			a | y => -> do
				send "Hello" on y
				halt y
			
		proc q ::  | => Get( [Char] | Y )  = 
			| => y do
				recv b on y
				halt y

	\end{verbatim}
	\vspace{-3em}
  \captionof{figure}{Send-Receive via \texttt{Get}}
  \label{Fig: Get process}
\end{minipage}
\end{figure}

A process may send on a left polarity channel when the channel is of type {\tt Get} and on a right polarity channel when the channel is of type {\tt Put}. A process may receive on a left polarity channel when the channel is of type {\tt Put} and on a right polarity channel when the channel is of type {\tt Get}. This usage of \texttt{Put} and \texttt{Get} channel types apply for channels which are instances of Protocols. For coProtocols, the interpretation is dual, as shown in the tables below:


\begin{center}
	\begin{tabular}{ c | c | c }
		     (P)       & (+) & (-) \\
		 \hline      
		 {\tt Get}  & {\tt recv}  & {\tt send} \\
		 \hline
		 {\tt Put}  & {\tt send}  & {\tt recv} 
	\end{tabular}
	\quad \quad 
	\begin{tabular}{ c | c | c }
		     (coP)       & (+) & (-) \\
		 \hline      
		 {\tt Get}  & {\tt send}  & {\tt recv} \\
		 \hline
		 {\tt Put}  & {\tt recv}  & {\tt send} 
	\end{tabular}
\end{center}

One may think of a channel of type \texttt{Put} as allowing information flow from left to right, and the type \texttt{Get} as allowing information flow from right to left. 

	
\section{CaMPL (Categorical Message Passing Language) notes}

CaMPL has concurrent and sequential types. Some useful tables and notes.

The following table summarizes the analogues of sequential and concurrent worlds.

\begin{center}
\begin{tabular}{ c | c | c | c }
 {\bf Sequential} & Datatypes  & Functions & Instances \\ 
   & (and coDatatypes)  &  &  \\
 \hline
 {\bf Concurrent} & Protocols & Processes & Channels \\  
 & (and coProtocols)  &  &  \\
\end{tabular}
\end{center}

Channels are instances of (co)protocols. Given a process and a channel {\em connected} to it, the channel may have input (+) or output polarity (-) for that process. 

Here are a few practical programming notes:
\begin{itemize}
	\item {\tt close} command closes a channel. {\tt halt} command is used on a process which has only one connected channel. Halt closes the channel and halts the process. 
	
	{\bf Design question:} Why not interpret closing all the channels as a signal to halt? For example: 
	\begin{verbatim}
		 close ch1  
		 close ch2  
		 halt
	\end{verbatim}
	
	\item The handles \tt{ConsoleGet}, \tt{ConsolePut}, \tt{ConsoleClose}, \tt{StringTerminalGet}, \tt{StringTerminalPut}, and \tt{StringTerminalClose} which are used for reading from and writing to terminals are hard-coded.  
	
\begin{center}
	\begin{tabular}{ c | c | c }
		     (P)       & (+) & (-) \\
		 \hline      
		 {\tt Get}  & {\tt get}  & {\tt put} \\
		 \hline
		 {\tt Put}  & {\tt put}  & {\tt get} 
	\end{tabular}
	\quad \quad 
	\begin{tabular}{ c | c | c }
		     (coP)       & (+) & (-) \\
		 \hline      
		 {\tt Get}  & {\tt put}  & {\tt get} \\
		 \hline
		 {\tt Put}  & {\tt get}  & {\tt put} 
	\end{tabular}
	\quad \quad 
	\begin{tabular}{ c | c | c }
		            & (+) & (-) \\
		 \hline      
		 (P)  & {\tt hput}  & {\tt hcase} \\
		 \hline
		 (coP)  & {\tt hcase}  & {\tt hput} 
	\end{tabular}
\end{center}
 
\end{itemize}



\section{Example: Echo Server}

\subsection*{Expected program behavior} There are two processes {\em a client} and {\em a server} communicating with one another. The server is connected to the environment via a console, and the client via a \texttt{StringTerminal}. The server reads a string from the terminal, relays it to the server who prints it on the console, and sends the string back to the client. When the user provides an empty string, the processes terminate. 

The topology of the processes and their connection remains the same throughout the program. The topology is shown in the diagram below:
<DIAGRAM>


\subsection*{CaMPL program}
The main protocol used in this program is \texttt{Echo}. It provides a handle \texttt{EchoSend} of Put-Get type which will be used to send-receive or receive-send a message depending on the polarity of channel ends. The handle \texttt{EchoClosed} is used to close a channel of \texttt{Echo} type. 

\begin{verbatim}
protocol Echo => S =
    EchoSend :: Put( [Char] | Get( [Char] | S)) => S
    EchoClose :: TopBot => S
\end{verbatim}

The client process is connected to a channel of \texttt{Echo} type at the output end. It first reads a string (provided by the user) from the terminal. If the user provided a non-empty string, it will place \texttt{EchoSend} handle on the channel followed by a \texttt{put} to send the string. Then, it performs a (blocking) \texttt{get} to receive data from server and loops. If the use provided an empty string, it signals the server by placing the \texttt{EchoClose} handle on the channel. It closes its connection and terminates.

\begin{verbatim}

proc client :: | => Echo, ClientConsole =
    | => ch, console -> do
        hput StringTerminalGet on console
        get fruit on console

        case fruit of
            [] -> do
                hput EchoClose on ch
                hput StringTerminalClose on console
                close console
                halt ch

            _:_ -> do
                hput EchoSend on ch
                -- send data
                put fruit on ch 
                -- receive echoed data
                get echoed on ch  
                -- print received data
                hput StringTerminalPut on console
                put ('>':' ':echoed) on console

                -- loop
                client( | => ch, console)
\end{verbatim}    

The server process is connected to a channel of \texttt{Echo} type at the input end. It first performs a (blocking) \texttt{hcase}. If the handle received is \texttt{EchoSend}, then it receives data (sent by the client) using a {blocking} \texttt{get}. It sends the received data back as an acknowledgement using a \texttt{put} (since the handle \texttt{EchoSend} does Put-Get), and loops. If the handle received is \texttt{EchoClose} then it closes it connection with the channel and terminates. 

\begin{verbatim}
proc server :: | Echo, LogConsole => =
    | ch, console => -> do
        hcase ch of
            EchoSend -> do
                -- receive data
                get fruit on ch

                -- print data
                hput ConsolePut on console
                put fruit on console

                -- echo (send) data 
                put fruit on ch
                server( | ch, console => )
            EchoClose -> do
                hput ConsolePut on console
                put "Done" on console
                hput ConsoleClose on console
                close console
                halt ch
\end{verbatim}

The following is the code for ClientConsole and the server's LogConsole for reading input and printing output. 

\begin{verbatim}

protocol ClientConsole => S =
    StringTerminalGet :: Get( [Char] | S) => S
    StringTerminalPut :: Put( [Char] | S) => S
    StringTerminalClose :: TopBot => S

coprotocol S => LogConsole =
    ConsolePut :: S => Get( [Char] | S)
    ConsoleClose :: S => TopBot
\end{verbatim}

The following process  is the first process to be invoked by the program which initiates the topology, and runs the client and the server. 

\begin{verbatim}
proc run :: | LogConsole => ClientConsole =
    | console_s => console_c -> plug
        client( | => ch, console_c )
        server( | ch, console_s => )

\end{verbatim}

The following items were suggested by Hashimoto as improvements to CaMPL syntax:

\begin{itemize}
	\item While we have \texttt{Get} and \texttt{Put} for protocols (which means get and put on the output polarity), it will be user-friendly \texttt{coGet} and \texttt{coPut} for coprotocols (to mean \texttt{put} and \texttt{get} respectively on the output terminal.
	\item Racing on handles instead of \texttt{put}. So be able to race on \texttt{hput}, and \texttt{fork} handles.
	\item Merge the \texttt{hput} followed by the get or put. 
	\item \texttt{on <channel> hput <handle>} instead of \texttt{hput <handle> on <channel>}. 
	\item Currently, to halt a process, the channels are first closed and the final \texttt{halt <channel>} command takes in the name of the last channel to be closed. Instead, close all the channels followed by \texttt{halt} command.
\end{itemize}

\end{document}
